      program fft1   
c $Id: fft1.for 181 2008-08-14 23:19:51Z tjansson $
c the program computes the fourier transform of 1-D data using FFT,
c and transforms it back  after tampering or band-pass filtering.
c adapted from R.Forsberg's program geofour,
c 2006-09-27 by C.C.Tscherning. Last change 2006-10-25.
c
      implicit none
c
      logical ltest,lbandp,ltampe,lmean
      integer nnarr(2),nyqn,nyqe,j,minwav,maxwav,itampe,ntampe
      integer idim, idim2,iwkdim,i,n,nv,ndata,iformat,nspline,
     *ifrac,maxspl,nmean,k
      character*72 ifile,ofile,ofile1,ofile2,udate
c
c  array dimensions: idim - max number of grid points 
c
      parameter (idim=5080000,iwkdim=10400000,maxspl=600)
      integer istno(idim)
      real*8 pdata(12),back(idim),pi,difmax,difmin,dt,d0,d1,d2,dp,
     *cha(2,  idim),s,rlat(idim),rlon(idim),h(idim),ss,
     *wrk(  iwkdim),dstart,dstop,dslope,dmean,spline,y(maxspl),
     *r(maxspl),q(maxspl),x,fmin,fmax
c
      idim2 = 2*idim
      d0=0.0d0
      d1=1.0d0
      d2=2.0d0
c
      pi = atan(d1)*4.0d0
      write(*,*)' FFT 1 D, 2006-10-27 '
      call fdate(udate)
      write(*,*)udate
      write(*,*)' input t if test otherwise f '
      write(*,*)' (in test-mode, data will be generated by progr.) '
      read(*,*)ltest
      write(*,*)ltest
      write(*,*)' Bandpass used (t/f) '
      read(*,*)lbandp
      write(*,*)lbandp
      if (lbandp) then
       write(*,*)' input min and max frequency (Hz) '
       read(*,*)fmin,fmax       
       write(*,180)fmin,fmax    
 180   format(2f10.5)
      end if
      write(*,*)' Tampering used (t/f) ? '
      read(*,*)ltampe
      write(*,*)ltampe
      if (ltampe) then
       write(*,*)
     *' input 1 for cosine-tampering, 2 for linear correction '
       write(*,*)' or 3 for spline-function '
       read(*,*)itampe
       write(*,*)itampe
       if (itampe.eq.1) then
        write(*,*)' input number of points tampered '
        read(*,*)ntampe
        write(*,*)ntampe
        write(*,*)' mean removed before tampering ? (t/f) '
        read(*,*)lmean
        write(*,*)lmean
       end if
c added 2006-10-26.
       if (itampe.eq.3) then
        write(*,*)' input number of spline nodes '
        read(*,*)nspline
        write(*,*)nspline
        if (nspline.gt.maxspl) then
         write(*,*)' value too large, change maxspl ',maxspl
         stop
        end if
       end if
      end if
c
c  read input data 
      if (ltest) then
       write(*,*)' read number of points and wavenumber '
       read(*,*)n,nv
       write(*,*)n,nv
      else
       write(*,*)' input name of input and output-files '
       write(*,*)' name of data file '
       read(*,('a'))ifile
       write(*,*)' name of file to hold PSD and Fourier coefficients '
       read(*,('a'))ofile
       write(*,*)' name of file to hold filtered data '
       read(*,('a'))ofile1
       write(*,*)' name of file to hold filtered Fourier coefficients '
       read(*,('a'))ofile2
       open(12,file=ifile)
       open(13,file=ofile)
       open(14,file=ofile1)
       open(15,file=ofile2)
       write(*,*)ifile,ofile,ofile1
       write(*,*)' read number of points '
       read(*,*)n
       write(*,*)n
       if (n.gt.idim) then
        write(*,*)' n too large '
        stop
       end if
       write(*,*)' input time interval between measurements '
       read(*,*)dt
       write(*,180)dt
       if (lbandp) then
        minwav=fmin*n*dt  
        maxwav=fmax*n*dt  
        write(*,181)minwav,maxwav
 181    format(' min and max wave-number ',2i10)
       else
        minwav=-1
        maxwav=idim+1
       end if
       write(*,*)' input number of data-elements after h '
       read(*,*)ndata
       write(*,*)ndata
       if (ndata.gt.12) then
        write(*,*)' too large '
        stop
       end if
      end if 
      write(*,*)' Select output format '
      write(*,*)' f8.4: type 1 '
      write(*,*)' f10.4: type 2 '
      write(*,*)' d13.5: type 3 '
      read(*,*)iformat
      write(*,*)iformat
c
      nyqn = n/2+1
      write(*,*)' Nyquist-wavenumber = ',nyqn
      nyqe = 1
      if (maxwav.gt.nyqn) then
       write(*,*)' upper band-limit must be below Nyqu. '
       maxwav=nyqn
      end if
      s = d0  
      dmean=d0
      do i = 1, n
       if (ltest) then
c creation of test-data with distinct spetral elements.
        cha(1,i)=cos(nv*(i-d1)*d2*pi/n)+d1
     *  +sin(nv*(i-d1)*d2*pi/n)
        back(i)=cha(1,i)
        s = s +cha(1,i)**2
        write(*,135)cha(1,i)
 135    format(3f12.5)
       else
        read(12,*)istno(i),rlat(i),rlon(i),h(i),(pdata(j),j=1,ndata)
        cha(1,i)=pdata(ndata)
        if (iformat.eq.1.and.cha(1,i).gt.99.999.or.cha(1,i).lt.-9.9999)
     *  iformat=2
        if (iformat.eq.2.and.cha(1,i).gt.9999.999.or.
     *  cha(1,i).lt.-999.9999) iformat=3
        back(i)=pdata(ndata)
        if (i.lt.5) write(*,135)cha(1,i)
        dmean=dmean+cha(1,i)
        s = s +cha(1,i)**2
       end if
       cha(2,i)=d0
      end do   
      dmean=dmean/n
      write(*,140)dmean,s/n
 140  format(' mean value ',d16.7,/,' power in space domain ',d16.7)
C
      if (ltampe) then
       if (itampe.eq.1) then
        if (lmean)dmean=d0
        do i=1,ntampe
c cosine-tampering.
         cha(1,i)=dmean+(cha(1,i)-dmean)*cos(pi/(2*ntampe)*(ntampe-i+1))
         cha(1,n-i+1)=dmean+(cha(1,n-i+1)-dmean)*cos(pi/(2*ntampe)
     *   *(ntampe-i+1))
        end do
       end if
       if (itampe.eq.2) then
        dstart=cha(1,1)
        dstop =cha(1,n)
        dslope=(dstop-dstart)/n
        s=d0
        do i=1,n
c correction for linear trend.
         cha(1,i)=cha(1,i)-dslope*(i-1)-dstart
         s = s+cha(1,i)**2
        end do
        write(*,201)s/n
 201    format(' Power after linear removal= ',d15.6)
       end if
       if (itampe.eq.3) then
        nmean=n/nspline
        write(*,203)nmean
  203   format(' mean values will be formed over ',i6,' values ')
        k=0
        do i=1,nspline
         y(i)=d0
         do j=1,nmean
          k=k+1
          if (k.le.n) then
           y(i)=y(i)+cha(1,k)
          end if
         end do
         y(i)=y(i)/nmean
         write(*,204)i,y(i)
  204    format(i6,f12.5)
        end do
        call initsp(y, nspline, r, q)
c subtraction of spline-function approximation.
        dmean=d0
        s=d0
        do i=1,n
         x=(i-d1)/nmean+1-0.5d0
         cha(1,i)=cha(1,i)-spline(x, y, nspline, r)
         dmean=dmean+cha(1,i)
         s=s+cha(1,i)**2
        end do
        write(*,207)dmean/n,s/n
 207    format(' Mean and Power after spline removal= ',2d15.6)
       end if
      end if
c
c  fourier transformation of data
c  ------------------------------
      nnarr(1) = n   
      nnarr(2) = 0   
c
      call fourt(cha,nnarr,1,-1,0,wrk,idim2,iwkdim)
c the subroutine calculates the complex coefficients of the
c fourier expansion. Hence they myst be multiplied by 2 and
c the sign on the complex component must be switched in order
c to obtain the coefficients of the real series.
c
c  scale transform
c
      s = d0
      dp=d1
      do i = 1,n
        cha(1,i) = cha(1,i)/n
        cha(2,i) = cha(2,i)/n
        if (i.le.nyqn) s = s + (cha(1,i)**2 + cha(2,i)**2)*dp
        dp=d2
        if (ltest) write(*,147)i,cha(1,i),cha(2,i),s
 147    format(i10,3d16.8)
      end do
      write(*, 54) s
 54   format(' power freq. domain    ',d16.7)
c
      dp=d1
      do i = 1, nyqn
        if (i.lt.5.or.ltest) write(*,135)cha(1,i)*dp,-cha(2,i)*dp
        if (lbandp) then
         if (i.lt.minwav.or.i.gt.maxwav) then
          cha(1,i)=d0
          cha(2,i)=d0
          if (i.gt.1) then
           cha(1,n-i+1)=d0
           cha(2,n-i+1)=d0
          end if
         end if
        end if
        if (i.ge.minwav.and.i.le.maxwav) 
     *  write(13,136)i/(dt*n),sqrt(cha(1,i)**2+cha(2,i)**2),
     *  cha(1,i)*dp,-cha(2,i)*dp
 136    format(4d16.8)
        dp=d2
      end do   
      if (lbandp) then
       if (ltest) then
        write(*,*)' Filtered coefficients '
        do i=1,n
         write(*,147)i,cha(1,i),cha(2,i)
        end do
       else
        do i=1,nyqn
         write(15,147)i,cha(1,i),cha(2,i)
        end do
       end if
      end if  
c
c  reverse fourier transformation
c  ------------------------------
c
      write(*,*)
      write(*,*)' Now reverse transformation '
      call fourt(cha,nnarr,1,1,1,wrk,idim2,iwkdim)
c
      s=d0
      ss=d0
c
      difmax=-1.0d5
      difmin= 1.0d5
      write(*,*)' Output reverse tranformed or filtered data '
      do i = 1, n
        if (i.lt.5.or.ltest)
     *  write(*,135)cha(1,i),cha(2,i),cha(1,i)-back(i)
        if (difmax.lt.(cha(1,i)-back(i))) difmax=cha(1,i)-back(i)  
        if (difmin.gt.(cha(1,i)-back(i))) difmin=cha(1,i)-back(i)  
        if (iformat.eq.1)
     *  write(14,150)istno(i),rlat(i),rlon(i),h(i),back(i),
     *  back(i)-cha(1,i),cha(1,i)
 150    format(I10,f10.5,f11.5,f10.1,3f8.4)
        if (iformat.eq.2)
     *  write(14,151)istno(i),rlat(i),rlon(i),h(i),back(i),
     *  back(i)-cha(1,i),cha(1,i)
 151    format(I10,f10.5,f11.5,f10.1,3f10.4)
        if (iformat.eq.3)
     *  write(14,152)istno(i),rlat(i),rlon(i),h(i),back(i),
     *  back(i)-cha(1,i),cha(1,i)
 152    format(I10,f10.5,f11.5,f10.1,3d13.5)
        s=s+cha(1,i)-back(i)  
        ss=ss+(cha(1,i)-back(i))**2
      end do    
c
      write(*,*)' mean and stdv. for difference forw. - back '
      write(*,*)' and min, max difference '
      ss=(ss-s**2/(n-1))/n
      if (ss.lt.1.0d-20) ss=d0
      ss=sqrt(ss)
      write(*,138)s/n,ss,difmin,difmax
 138  format(4d16.8)
c
      close(12)
      close(13)
      close(14)
      call fdate(udate)
      write(*,*)udate
      stop
      end
c
      subroutine fourt(datt,nn,ndim,isign,iform,work,idim1,idim2)
cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
c
c                     f o u r t
c
c        version=740301
c        program description norsar n-pd9 dated 1 july 1970
c        author n m brenner
c        further description    three fortran programs etc.
c        issued by lincoln laboratory, mit, july 1967
c        two corrections by hjortenberg 1974
c     the fast fourier transform in usasi basic fortran
c
c     modified to rc fortran rf june 84
c
cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
      implicit double precision(a-h,o-z)
      dimension datt(idim1),nn(ndim),ifact(32),work(idim2)
c
      np0=0
      nprev=0
c
      twopi=6.283185307d0
      rthlf=.7071067812d0
      if(ndim-1)920,1,1
1     ntot=2
      do 2 idim=1,ndim
      if(nn(idim))920,920,2
2     ntot=ntot*nn(idim)
c
c     mainloop for each dimension
c
      np1=2
      do 910 idim=1,ndim
      n=nn(idim)
      np2=np1*n
      if(n-1)920,900,5
c
c     is n a power of two and if not, what are its factors
c
5     m=n
      ntwo=np1
      if=1
      idiv=2
10    iquot=m/idiv
      irem=m-idiv*iquot
      if(iquot-idiv)50,11,11
11    if(irem)20,12,20
12    ntwo=ntwo+ntwo
      ifact(if)=idiv
      if=if+1
      m=iquot
      go to 10
20    idiv=3
      inon2=if
30    iquot=m/idiv
      irem=m-idiv*iquot
      if(iquot-idiv)60,31,31
31    if(irem)40,32,40
32    ifact(if)=idiv
      if=if+1
      m=iquot
      go to 30
40    idiv=idiv+2
      go to 30
50    inon2=if
      if(irem)60,51,60
51    ntwo=ntwo+ntwo
      go to 70
60    ifact(if)=m
70    non2p=np2/ntwo
c
c     separate four cases---
c        1. complex transform
c        2. real transform for the 2nd, 3nd, etc. dimension.  method--
c           transform half the datt, supplying the other half by con-
c           jugate symmetry.
c        3. real transform for the 1st dimension,n odd.  method--
c           set the imaginary parts to zero
c        4. real transform for the 1st dimension,n even.method--
c           transform a complex array of lenght n/2 whose real parts
c           are the even numberd real values and whose imaginary parts
c           are the odd numberedreal values.  separate and supply
c           the second half by conjugate summetry.
c
      icase=1
      ifmin=1
      i1rng=np1
      if(idim-4)74,100,100
74    if(iform)71,71,100
71    icase=2
      i1rng=np0*(1+nprev/2)
      if(idim-1)72,72,100
72    icase=3
      i1rng=np1
      if(ntwo-np1)100,100,73
73    icase=4
      ifmin=2
      ntwo=ntwo/2
      n=n/2
      np2=np2/2
      ntot=ntot/2
      i=1
      do 80 j=1,ntot
      datt(j)=datt(i)
80    i=i+2
c
c     shuffle datt by bit reversal, since n=2**k.  as the shuffling
c     can be done by simple interchange, no working array is needed
c
100   if(non2p-1)101,101,200
101   np2hf=np2/2
      j=1
      do 150 i2=1,np2,np1
      if(j-i2)121,130,130
121   i1max=i2+np1-2
      do 125 i1=i2,i1max,2
      do 125 i3=i1,ntot,np2
      j3=j+i3-i2
      tempr=datt(i3)
      tempi=datt(i3+1)
      datt(i3)=datt(j3)
      datt(i3+1)=datt(j3+1)
      datt(j3)=tempr
125   datt(j3+1)=tempi
130   m=np2hf
140   if(j-m)150,150,141
141   j=j-m
      m=m/2
      if(m-np1)150,140,140
150   j=j+m
      go to 300
c
c     shuffle datt by digit reversal for general n
c
200   nwork=2*n
      do 270 i1=1,np1,2
      do 270 i3=i1,ntot,np2
      j=i3
      do 260 i=1,nwork,2
      if(icase-3)210,220,210
210   work(i)=datt(j)
      work(i+1)=datt(j+1)
      go to 240
220   work(i)=datt(j)
      work(i+1)=0.
240   ifp2=np2
      if=ifmin
250   ifp1=ifp2/ifact(if)
      j=j+ifp1
      if(j-i3-ifp2)260,255,255
255   j=j-ifp2
      ifp2=ifp1
      if=if+1
      if(ifp2-np1)260,260,250
260   continue
      i2max=i3+np2-np1
      i=1
      do 270 i2=i3,i2max,np1
      datt(i2)=work(i)
      datt(i2+1)=work(i+1)
270   i=i+2
c
c     main loop for factors of two
c     w=exp(isign*2*pi*sqrt(-1)*m/(4*mmax)).  check for w=isign*sqrt(-1)
c     and repeat for w=w*(1+isign*sqrt(-1))/sqrt(2)
c
300   if(ntwo-np1)600,600,305
305   np1tw=np1+np1
      ipar=ntwo/np1
310   if(ipar-2)350,330,320
320   ipar=ipar/4
      go to 310
330   do 340 i1=1,i1rng,2
      do 340 k1=i1,ntot,np1tw
      k2=k1+np1
      tempr=datt(k2)
      tempi=datt(k2+1)
      datt(k2)=datt(k1)-tempr
      datt(k2+1)=datt(k1+1)-tempi
      datt(k1)=datt(k1)+tempr
340   datt(k1+1)=datt(k1+1)+tempi
350   mmax=np1
360   if(mmax-ntwo/2)370,600,600
370   lmax=max0(np1tw,mmax/2)
      do 570 l=np1,lmax,np1tw
      m=l
      if(mmax-np1)420,420,380
380   theta=-twopi*dble(l)/dble(4*mmax)
      if(isign)400,390,390
390   theta=-theta
400   wr=cos(theta)
      wi=sin(theta)
410   w2r=wr*wr-wi*wi
      w2i=2.*wr*wi
      w3r=w2r*wr-w2i*wi
      w3i=w2r*wi+w2i*wr
420   do 530 i1=1,i1rng,2
      kmin=i1+ipar*m
      if(mmax-np1)430,430,440
430   kmin=i1
440   kdif=ipar*mmax
450   kstep=4*kdif
      if(kstep-ntwo)460,460,530
460   do 520 k1=kmin,ntot,kstep
      k2=k1+kdif
      k3=k2+kdif
      k4=k3+kdif
      if(mmax-np1)470,470,480
470   u1r=datt(k1)+datt(k2)
      u1i=datt(k1+1)+datt(k2+1)
      u2r=datt(k3)+datt(k4)
      u2i=datt(k3+1)+datt(k4+1)
      u3r=datt(k1)-datt(k2)
      u3i=datt(k1+1)-datt(k2+1)
      if(isign)471,472,472
471   u4r=datt(k3+1)-datt(k4+1)
      u4i=datt(k4)-datt(k3)
      go to 510
472   u4r=datt(k4+1)-datt(k3+1)
      u4i=datt(k3)-datt(k4)
      go to 510
480   t2r=w2r*datt(k2)-w2i*datt(k2+1)
      t2i=w2r*datt(k2+1)+w2i*datt(k2)
      t3r=wr*datt(k3)-wi*datt(k3+1)
      t3i=wr*datt(k3+1)+wi*datt(k3)
      t4r=w3r*datt(k4)-w3i*datt(k4+1)
      t4i=w3r*datt(k4+1)+w3i*datt(k4)
      u1r=datt(k1)+t2r
      u1i=datt(k1+1)+t2i
      u2r=t3r+t4r
      u2i=t3i+t4i
      u3r=datt(k1)-t2r
      u3i=datt(k1+1)-t2i
      if(isign)490,500,500
490   u4r=t3i-t4i
      u4i=t4r-t3r
      go to 510
500   u4r=t4i-t3i
      u4i=t3r-t4r
510   datt(k1)=u1r+u2r
      datt(k1+1)=u1i+u2i
      datt(k2)=u3r+u4r
      datt(k2+1)=u3i+u4i
      datt(k3)=u1r-u2r
      datt(k3+1)=u1i-u2i
      datt(k4)=u3r-u4r
520   datt(k4+1)=u3i-u4i
      kdif=kstep
      kmin=4*(kmin-i1)+i1
      go to 450
530   continue
      m=m+lmax
      if(m-mmax)540,540,570
540   if(isign)550,560,560
550   tempr=wr
      wr=(wr+wi)*rthlf
      wi=(wi-tempr)*rthlf
      go to 410
560   tempr=wr
      wr=(wr-wi)*rthlf
      wi=(tempr+wi)*rthlf
      go to 410
570   continue
      ipar=3-ipar
      mmax=mmax+mmax
      go to 360
c
c     main loop for factoers not equal to two
c     w=exp(isign*2*pi*sqrt(-1)*(j1+j2-i3-1)/ifp2)
c
600   if(non2p-1)700,700,601
601   ifp1=ntwo
      if=inon2
610   ifp2=ifact(if)*ifp1
      theta=-twopi/dble(ifact(if))
      if(isign)612,611,611
611   theta=-theta
612   wstpr=cos(theta)
      wstpi=sin(theta)
      do 650 j1=1,ifp1,np1
      thetm=-twopi*dble(j1-1)/dble(ifp2)
      if(isign)614,613,613
613   thetm=-thetm
614   wminr=cos(thetm)
      wmini=sin(thetm)
      i1max=j1+i1rng-2
      do 650 i1=j1,i1max,2
      do 650 i3=i1,ntot,np2
      i=1
      wr=wminr
      wi=wmini
      j2max=i3+ifp2-ifp1
      do 640 j2=i3,j2max,ifp1
      twowr=wr+wr
      j3max=j2+np2-ifp2
      do 630 j3=j2,j3max,ifp2
      jmin=j3-j2+i3
      j=jmin+ifp2-ifp1
      sr=datt(j)
      si=datt(j+1)
      oldsr=0.
      oldsi=0.
      j=j-ifp1
620   stmpr=sr
      stmpi=si
      sr=twowr*sr-oldsr+datt(j)
      si=twowr*si-oldsi+datt(j+1)
      oldsr=stmpr
      oldsi=stmpi
      j=j-ifp1
      if(j-jmin)621,621,620
621   work(i)=wr*sr-wi*si-oldsr+datt(j)
      work(i+1)=wi*sr+wr*si-oldsi+datt(j+1)
630   i=i+2
      wtemp=wr*wstpi
      wr=wr*wstpr-wi*wstpi
640   wi=wi*wstpr+wtemp
      i=1
      do 650 j2=i3,j2max,ifp1
      j3max=j2+np2-ifp2
      do 650 j3=j2,j3max,ifp2
      datt(j3)=work(i)
      datt(j3+1)=work(i+1)
650   i=i+2
      if=if+1
      ifp1=ifp2
      if(ifp1-np2)610,700,700
c
c     complete areal transform in the 1st dimension, n even, by con-
c     jugate symmetries
c
700   go to (900,800,900,701),icase
701   nhalf=n
      n=n+n
      theta=-twopi/dble(n)
      if(isign)703,702,702
702   theta=-theta
703   wstpr=cos(theta)
      wstpi=sin(theta)
      wr=wstpr
      wi=wstpi
      imin=3
      jmin=2*nhalf-1
      go to 725
710   j=jmin
      do 720 i=imin,ntot,np2
      sumr=(datt(i)+datt(j))/2.
      sumi=(datt(i+1)+datt(j+1))/2.
      difr=(datt(i)-datt(j))/2.
      difi=(datt(i+1)-datt(j+1))/2.
      tempr=wr*sumi+wi*difr
      tempi=wi*sumi-wr*difr
      datt(i)=sumr+tempr
      datt(i+1)=difi+tempi
      datt(j)=sumr-tempr
      datt(j+1)=-difi+tempi
720   j=j+np2
      imin=imin+2
      jmin=jmin-2
      wtemp=wr*wstpi
      wr=wr*wstpr-wi*wstpi
      wi=wi*wstpr+wtemp
725   if(imin-jmin)710,730,740
730   if(isign)731,740,740
731   do 735 i=imin,ntot,np2
735   datt(i+1)=-datt(i+1)
740   np2=np2+np2
      ntot=ntot+ntot
      j=ntot+1
      imax=ntot/2+1
745   imin=imax-2*nhalf
      i=imin
      go to 755
750   datt(j)=datt(i)
      datt(j+1)=-datt(i+1)
755   i=i+2
      j=j-2
      if(i-imax)750,760,760
760   datt(j)=datt(imin)-datt(imin+1)
      datt(j+1)=0.
      if(i-j)770,780,780
765   datt(j)=datt(i)
      datt(j+1)=datt(i+1)
770   i=i-2
      j=j-2
      if(i-imin)775,775,765
775   datt(j)=datt(imin)+datt(imin+1)
      datt(j+1)=0.
      imax=imin
      go to 745
780   datt(1)=datt(1)+datt(2)
      datt(2)=0.
      go to 900
c
c     complete a real transform for the 2nd, 3rd, etc. dimension by
c     conjugate symmetries.
c
800   if(i1rng-np1)805,900,900
805   do 860 i3=1,ntot,np2
      i2max=i3+np2-np1
      do 860 i2=i3,i2max,np1
      imax=i2+np1-2
      imin=i2+i1rng
      jmax=2*i3+np1-imin
      if(i2-i3)820,820,810
810   jmax=jmax+np2
820   if(idim-2)850,850,830
830   j=jmax+np0
      do 840 i=imin,imax,2
      datt(i)=datt(j)
      datt(i+1)=-datt(j+1)
840   j=j-2
850   j=jmax
      do 860 i=imin,imax,np0
      datt(i)=datt(j)
      datt(i+1)=-datt(j+1)
860   j=j-np0
c
c     end of loop on each dimension
c
900   np0=np1
      np1=np2
910   nprev=n
920   return
      end
c
cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
c                                                                  c
c                      i n i t s p                                 c
c                                                                  c
c  initialization procedure for fast 1-dimensional equidistant     c
c  spline interpolation, with free boundary end conditions         c
c  reference: josef stoer: einfuhrung in die numerische mathematik c
c  i, springer 1972.                                               c
c                                                                  c
c  parameters (real):                                              c
c                                                                  c
c  y  given values, y(1), ..., y(n)                                c
c                                                                  c
c  r  spline moments (1 ... n), to be used by function 'spline'    c
c                                                                  c
c  q  work-array, declared at least 1:n                            c
c                                                                  c
c  rene forsberg, july 1983                                        c
c                                                                  c
cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
c
      subroutine initsp(y, n, r, q)
c
      implicit double precision(a-h,o-z)
      integer maxspl
      parameter (maxspl=600)
      dimension y(maxspl), r(maxspl), q(maxspl)
c
      q(1) = 0.0
      r(1) = 0.0
      do 11 k = 2, n-1
        p = q(k-1)/2+2
        q(k) = -0.5/p
        r(k) = (3*(y(k+1)-2*y(k)+y(k-1)) - r(k-1)/2)/p
   11 continue
      r(n) = 0.0
      do 12 k = n-1, 2, -1
        r(k) = q(k)*r(k+1)+r(k)
   12 continue
      return
      end
c
cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
c                                                                  c
c                          s p l i n e                             c
c                                                                  c
c  fast one-dimensional equidistant spline interpolation function. c
c                                                                  c
c  parameters:                                                     c
c                                                                  c
c  x   interpolation argument (real), x = 1 first data-point,      c
c      x = n last data-point. outside the range linear extra-      c
c      polation is used.                                           c
c                                                                  c
c  y   real*8 array, 1 .. n : data values                          c
c                                                                  c
c  r   do: spline moments calculated by subroutine 'initsp'        c
c                                                                  c
c  programmer:                                                     c
c  rene forsberg, june 1983                                        c
c                                                                  c
cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
c
      double precision function spline(x, y, n, r)
c
      implicit double precision (a-h, o-z)
      integer maxspl
      parameter (maxspl=600)
      dimension y(maxspl), r(maxspl)
c
      if(x.ge.1.0) go to 1
        spline = y(1) + (x-1)*(y(2)-y(1)-r(2)/6)
      return
    1 if(x.le.float(n)) go to 2
        spline = y(n) + (x-n)*(y(n)-y(n-1)+r(n-1)/6)
      return
    2   j = ifrac(x)
        xx = x - j
        spline = y(j) +
     .           xx * ((y(j+1)-y(j)-r(j)/3-r(j+1)/6) +
     .           xx * (r(j)/2 +
     .           xx * (r(j+1)-r(j))/6))
      return
      end
c
      integer function ifrac(r)
      implicit double precision(a-h,o-z)
      if (r.lt.0) goto 10
      ifrac = r
      return
10    i = r
      if (i.eq.r) goto 20
      ifrac = i-1
      return
20    ifrac = i
      return
      end
