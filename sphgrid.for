      program sphgrid
c $Id: sphgrid.for 181 2008-08-14 23:19:51Z tjansson $
c program to test FS's equations for the prediction of spherical
c harmonic coefficients using fast Least-Squares Collocation (LSC)
c from data gridded equitantly in longitude. Error estimates are
c also calculated.
c
c For each latitude the data must be of the same kind, be in
c the same altitude and have the same error.
c Presently 5 kinds of data can be used, identified by an integer code:
c Data type                    code     units
c anomalous potential (T)          10     m**2/s**2
c geoid height                     11     m
c gravity disturbance              12     mgal
c gravity anomaly                  13     mgal
c vertical gravity gradient (Tzz)  15     E.U.
c
c Data may be point or mean values. Means are calculated as the mean
c of nstep*nstep values. Actual value of nstep is found in parameter
c statement and must be an un-even number.
c
c The data may be generated using a spherical harmonic expansion or
c input from a (binary) file containing data generated by an earlier run    
c of the program.
c
c Note that data-types may be mixed and in different altitudes.
c Also in this case both geodetic and geocentric coordinates may
c be used.
c
c The program may be run in spherical approximation, i.e. so that
c the distance from the origin is calculated as the sum of the mean 
c earth-radius and the altitude. 
c Various testing possibilities have been implemented. The most important
c is that a full LSC solution may be calculated when the number of data is 
c small.  Furthermore an alternative method for calculating associated
c Legendre functions has been implemented, and the results for the
c routine (lecurs) may be compared to the simpler spharm0 routine
c which is based on standard recursion algorithms. Problems are
c to be expected for high degree and high latitude.
c
c Input may be done interactively or by preparing an input file
c for batch processing. Input has the following structure:
c
c use spherical approximation ? (t/f)                      F 
c Test of program (T/F)                                    F 
c Is the grid equidistant in latitude ? (T/F)              T
c input gravsoft grid label (latmin,max,lonmin,max,dlat,dlon)
c using geodetic latitude.
c                              -80.0 80.0 0.0 340.0 20.0 20.0
c input altitude of points (m)                         300000.0
c input functional type (10: anomalous potential, 11: geoid,
c      13: gravity, 15: Tzz   13
c input common standard deviation of noise                  0.005
c are all data mean values (T/F) ?                         F
c input degree of spherical harmonic expansion            180
c input name of file to hold calculated coefficients
c used for coparison or data generation                   ccoeff
c input name of file with coefficients                    pcoeff
c read formatted (T/F) ?                                   T
c input format e.g. (2I4,2d19.12)                (2I4,2d20.12)
c input minimum and maximal degree of degree-variances    2 180 
c input name of file with degree-variances (units mgal**2)  egm96.edg
c input maximal degree for prediction                       8  
c output of error-estimate for max. degree to file ?        T
c input name of file to hold error-estimates              eco8.dat
c Input observations from file ? (T/F)                      F
c   IF T, then input of file-name, number of data-items, and
c   the number in the data list of the data to be used
c   followed (on a new line) t if data are geodetic coordinates and
c   f if they are geocentric.
c   If F, data will be generated by the program from the
c   coefficients.
c Output of observations to file (T/F)                      F
c Will covariances be input from file (T/F) ?               F
c   This can be used if the file covsph has been renamed
c   and the same data are used again, with a new standard
c   deviation of the error.
c Output of coefficients and differences ? (T/F)            T
c
c Output consist of the input parameters, predicted and observed
c coefficients and their standard deviation. A summary of the
c results are given. If both full LSC and  fast LSC is used
c a comparison of the results is made.
c The covariance functions used in fast LSC are stored on a file
c an overwritten in the next run if not renamed. It may be rather large.
c
c Programmed 2000-10-31 by cct, update 2003-08-22. 
c
c Reference:
c Sanso', F. and C.C.Tscherning: Fast Spherical Collocation - Theory and 
c Examples. J. of Geodesy, Vol. 77, pp. 101-112, DOI 10.1007/s00190-002-0310-5, c 2003.     
c
      implicit none
      integer maxgrid,maxcof,maxd,maxobs,nstepi,nc,izero,i,j1,
     *nsteps,irec,nnarr,ks,j,kj,m,n,iha,iko,maxdeg,ih,
     *molda,nolda,ih1,kt,idim,iwkdim,idim2,nchlis,nwarn,k,maxcc,
     *n1,ikp,maxc,nd2,nstep,nn1,ncof,mout,maxpre,
     *maxd2,ki0,num,ki,idm,jdm,iolda,jolda,k0,i0,k2,k3,ikold,
     *ik1old,ik,k1,ik1,i1,j4,issd,m1,n3,n4,ii,ka,kb,n1s,i5,icout,
     *ip,iq,mindeg,n2,ipk,nerror,j5,n11,m4,m3,ma,nout,idata,ndata
      parameter (maxgrid=4050,maxcof=360,maxd=1800,maxobs=720*360,
     *nstepi=3) 
c nstepi is the number of steps in the numerical integration of mean
c values.
      real*8 D0,D1,D2,D3,D4,D5,RE,PI,GM,fact,cov,
     *slat,a,clat,pim0,root,sq2,degv,cs,cc,cof,rlatg,rlatold,
     *rlon,sslon,cclon,disto,rlat,rlatc,hh,ra,ddlon,sdlon,rlatm,rlat0,
     *sno,snoise,h,dlon,dlod,dlad,rlonmad,rlonmid,
     *rlatmid,rem,fc,gra,pi4,e2,re2,ycc,yc,dyc,gjk,
     *dlfac,rlat1,rlon1,ss,rh,pnmr,pnm,fac,rj,dycmax,datin,dat0,
     *hinp,rloni,rlati,ssdat,sdat,g,s,si,pnm1,deg0,rlonmax,rlonmin,
     *dlat,rlatmin,sscv0,sscv,cv,cvmax,cvmin,cofr,err0,err2,
     *suaa,rc,cc0,rji,ycs,c0,pred,var,ssdegx,s1,t,rlonm,slatj,
     *clatj,c,fac2,fac1,rai,rlonj,slati,clati,ddyc,rlatmad,radeg,
     *degn2,sdeg,ssdeg,covf,g0mij,covff,sua,ssua,enlon,ci,error,
     *ersum,dsum,ddsum,cdif,cvari,d10,spharm0,cmean,y,slon,clon,z,
     *raddeg,dist2,xy2,xy,x,wrk,cnm,snm,ecnm,esnm,fl,emean,hmean
c
      logical ltest,lt,lf,lsphap,lforma,lnocc,lident,loutcc,lt00,
     *loout,loinp,lerout,lmean,lmean1,lincov,lchlis,leqsym,lallme,
     *ltestc,lsin,lgeod,ldiout
c
      COMMON /DCON/D0,D1,D2,D3,D4,D5,RE,RADDEG,PI,GM,LTEST,LF,LT
      common /rrsph/root(0:maxd*2+2)
c root is a precomputed square root-table (root(0)=0 !).
      COMMON /EUCL/X,Y,Z,XY,XY2,DISTO,DIST2,rlatc
c resulting cartesian coordinates and geocentric latitude.
      character *72 cofile,ifile,forma,obsfil,erout,covfil,ccoff
      character *24 udate
      COMMON /ITRANC/A,E2   
      common /ww/cof((maxcof+1)**2),cofr(31**2,2),
c cof holds coefficients and cofr coefficients and error-estimates
c predicted by "full" collocation.
     *rlat(maxgrid,nstepi),rlat0(maxgrid,0:nstepi),
c rlat = geocentric latitude, rlat0 = geodetic latitude,
     *clat(maxgrid,nstepi),slat(maxgrid,nstepi),rlon(maxgrid),
     *clon(nstepi,maxgrid),slon(nstepi,maxgrid),
c clat,slat=cos and sin of latitude, rlon=longitudes,
     *ra(maxgrid,nstepi),hh(maxgrid),
c ra= length of radius-vector, in spherical approximation = R+hh.
     *g(maxgrid,maxgrid),
c g contains observations.
     *covf(maxgrid),c(maxgrid*(maxgrid+1)/2),rh(maxobs),izero(maxgrid),
c the array c will initially contain the covariances and the observations.
c it is an upper triangular matrix. rh holds right hand side of equations,
c (initially it is used to hold heights). izero position of first non-
c zero element in a column (here always = 1), see PRONLL.
     *degv(maxd),deg0(maxd),
c deg0 holds potential degree-varainces, degv the actual degree-variances.
     *sno(maxobs),iko(maxobs),rc(maxobs),
     *pnm(0:maxcof),pnm1(0:maxcof),sdeg(0:maxcof,8),
     *pnmr(maxgrid,5,nstepi),ersum(-maxcof:maxcof),
c pnmr are recursion elements used to evaluate spherical harmonics.
     *ssdeg(0:maxcof,8),fc(0:25),sscv(0:25),cv(0:25),nc(0:25),
     *iha(0:25),nolda(maxgrid,nstepi),molda(maxgrid,nstepi),
c control elements of degree and order in recursion.
     *lmean1(maxgrid)
c ra holds radius for each latitude.lmean1 holds values true if data
c on one parallel are mean values.
      dimension wrk(1320),nnarr(2),dat0(10)
      dimension cclon(maxgrid*nstepi),sslon(maxgrid*nstepi)
c cos and sin of j*delta longitude.
      equivalence (clon(1,1),cclon(1))
      equivalence (slon(1,1),sslon(1))
c
c Files:   UNIT        used for                        name
c          2       Storage of Legendre functions        pnmfile
c          3       Covariance functions                 covsph
c          4       Grid definition file                 sphgrid0
c          9       In/out-put observations              input
c         12       Input of sphericl harmonic coeff.    input
c         15       gravity degree-variances             input
c         16       covariance table at equator.         covsphtab
c         21       output of error-estimates            input
c
c initializing dimension-variables for fft. (Not implemented).
      idim=51200
      iwkdim=1320
      idim2=idim*2
C
c initialisation of variables in common DCON.
      lt=.true.
      lf=.false.
      lallme=lt
      ltest=lf
      lchlis=lt
      nchlis=0
      icout=0
      lmean=lf
      lt00=lt
      d0=0.0d0
      d1=1.0d0
      d2=2.0d0
      d3=3.0d0
      d4=4.0d0
      d5=5.0d0
c GRS80 constants.
      A=6378137.0d0
      RE=A
      RE2=RE*RE
      GM=3.986005D14
c     E2=6.69438D-4
C erroneous value used until 2003-06-10. fl is the inverse of the flattening.
      fl=298.2572204d0
      fl=(d2-d1/fl)/fl
      E2=fl
      sq2=sqrt(d2)
c
      pi4=atan(d1)
      pi=d4*pi4
      radeg=180.0d0/pi
      raddeg=180.0d0/pi
      emean=d0
      hmean=d0
      rlatold=-180.0d0
c scale factor for gravity 
      gra=GM/RE2
c initializing array with conversion factors.
      fc(0)=d1
      fc(10)=GM/RE
c conversion to m**2/s**2 for anomalous potential T.
      iha(10)=1
      iha(0)=0
      fc(13)=gra*1.0d5
      iha(13)=2
C converting to mgal.
      fc(11)=RE
      iha(11)=1
c converting to m.
      fc(15)=1.0d9*GM/(RE**3)
      iha(15)=3
c converting to EU  (10**-9 s**-2).
      nwarn=0
c
c establish a square-root table.
      if (maxd.lt.maxcof) then
       write(*,*)' maxd < ',maxcof,' (maxcof) '
       stop
      end if
      do k=0,(maxd+1)*2
       root(k)=sqrt(dfloat(k))
      end do
c
      maxcc=maxgrid*(maxgrid+1)/2
c since the matrix will be full, we set the elements of the
c array izero to zero. (See subroutine PRONLL).
      do i=1,maxgrid
       izero(i)=1
      end do
c
      write(*,*)
     *' Spherical Harmonic Prediction from data in grid, 2003-08-22.  '
      call fdate(udate)
      write(*,*)udate
c
      write(*,*)' use spherical approximation ? (t/f) '
      read(*,*)lsphap
      if (lsphap) then
       write(*,*)' Spherical approximation in use '
c
       REM=6371000.0d0
       write(*,28)rem
  28   format(' Mean radius set to ',f10.1,' m.')
      else
       write(*,*)' Spherical approximation NOT in use. '
      end if
c
      write(*,*)' Test of program (T/F) '
      read(*,*)ltest
      if (ltest) write(*,*)' Program runs in TEST mode '
      write(*,*)' Is the grid equidistant in latitude ? (T/F) '
      read(*,*)lident
      if (lident) then
       write(*,*)
     * ' input gravsoft grid label (latmin,max,lonmin,max,dlat,dlon)'
       write(*,*)' using geodetic latitude. '
       read(*,*)rlatmid,rlatmad,rlonmid,rlonmad,dlad,dlod
       write(*,51)rlatmid,rlatmad,rlonmid,rlonmad,dlad,dlod
  51   format('  Grid: ',6f8.3)
       N=(rlonmad-rlonmid)/dlod+1
       N1=(rlatmad-rlatmid)/dlad+1
       if (abs(rlonmad-rlonmid-(n-1)*dlod).gt.1.0d-8
     *  .or.abs(rlatmad-rlatmid-(n1-1)*dlad).gt.1.0d-8
     *  .or.abs(rlonmad-rlonmid+dlod-360.0d0).gt.1.0d-3) then
c change 2003-08-19.
        write(*,*)' grid does not match '
        STOP
       end if
       rlatmin=rlatmid/radeg
       dlat=dlad/radeg
       rlonmin=rlonmid/radeg
       dlon=dlod/radeg
c
       write(*,*)' input altitude of points (m) '
       read(*,*)h
c
       write(*,61)
  61   format(' input functional type (10: anomalous potential',
     * ' 11: geoid, 12: gravity, disturbance,'/
     * ' 13: gravity anomaly, 15: Tzz ')
       read(*,*)ikp
       lt00=ikp.eq.0
c
       write(*,*)' input common standard deviation of noise '
       read(*,*)snoise
C
       write(*,*)' are all data mean values (T/F) ? '
       read(*,*)lmean
c
       write(*,66)h,ikp,snoise,lmean
  66   format(' height ',f12.1,' m , functional type ',i3,
     * ' data noise ', d15.4,/,' data mean values ',l2)
C
c this is an aid to create input-files with non-uniform spacing in latitude.
       open(4,file='sphgrid0')
       do k=1,n1
        write(4,53)rlatmid+(k-1)*dlad,h,ikp,snoise,lmean
  53    format(f10.5,f10.1,i4,d10.3,l2)
       end do
       close(4)
       write(*,*)' Grid definition output to file sphgrid0 '
       lgeod=.true.
      else
       write(*,67)
  67   format(' Is grid given using geodetic latitude and ',
     * ' ellipsoidal height input T and ',/,
     * ' if geocentric latitude and r input F ')
       read(*,*)lgeod
       write(*,*)lgeod
       write(*,*)
     * ' input minimal and maximal longitude and grid spacing (deg.) '
       read(*,*)rlonmin,rlonmax,dlod
       N=(rlonmax-rlonmin)/dlod+1
       rlonmin=rlonmin/radeg
       dlon=dlod/radeg
       write(*,*) ' input number of parallels '
       read(*,*)N1
       write(*,*)' input table with values of: '
       if (lgeod) then
        write(*,*)
     *  ' latitude (deg.), height (m), data-type code, S.D.-observa. '
        write(*,*)' and logical, true if data are mean values '
       else
        write(*,*)
     *  ' geocentric latitude (deg.),  radius (m), data-type code,'
        write(*,*)
     *  ' S.D. observ. and logical, true if data are mean values '
       end if
  
      end if
      maxc=n*n1*(n*n1+1)/2
      nd2=n/2
c
      do k=1,n1
c rlat0 holds the geodetic latitude.
       if (lident) then
        sno(k)=snoise
        rlat0(k,0)=rlatmin+(k-1)*dlat
        lmean1(k)=lmean
        iko(k)=ikp
       else
        read(*,*)rlat0(k,0),h,iko(k),sno(k),lmean1(k)
        emean=emean+sno(k)
        hmean=hmean+h
        if (.not.lgeod) then
c added 2003-01-31.
c here h is the radius vector length.
         x=h*cos(rlat0(k,0)/raddeg)
         y=d0
         z=h*sin(rlat0(k,0)/raddeg)
c conversion to geodetic latitude and ellipsoidal height.
         call TRANS(rlatg,h)
         if (abs(rlatg*raddeg-rlat0(k,0)).gt.0.5d0)
     *   write(*,*)' new lat ',rlatg*raddeg,rlat0(k,0)
         rlat0(k,0)=rlatg*raddeg
c now h is the ellipsoidal height.
        end if
c
        lmean=lmean.or.lmean1(k)
        lt00=iko(k).eq.0
        rlat0(k,0)=rlat0(k,0)/radeg
       end if
       lallme=lallme.and.lmean1(k)
       ks=1
       rlatm=rlat0(k,0)
       if (lmean) then
        nstep=nstepi
        sdlon=dlon*(d1+nstepi)/(d2*nstepi)
        ddlon=dlon/nstepi
       else
        nstep=1
        sdlon=d0
        ddlon=d0
       end if
c
       do ks=1,nstep
c generate latitude for grid points.
        ra(k,ks)=h
        hh(k)=h
        rlat0(k,ks)=rlatm-sdlon+ks*ddlon
        clat(k,ks)=cos(rlat0(k,ks))
        slat(k,ks)=sin(rlat0(k,ks))
c calculating geocentric latitude (rlatc).
        call  EUCLID(clat(k,ks),slat(k,ks),d1,d0,H,E2,A)
c variables transferred through common-block /EUCL/
c now using geocentric latitude:
        if (abs(rlatc-rlat0(k,ks)).gt.pi/180.0) write
     *  (*,*)' warning ',rlatc,rlat0(k,ks)
        clat(k,ks)=cos(rlatc)
        slat(k,ks)=sin(rlatc)
        rlat(k,ks)=rlatc
        ra(k,ks)=DISTO
       end do
       ks=1
      end do
      if (.not.lident) write(*,435)hmean/n1,emean/n1
 435  format(' mean altitude = ',f12.1,' mean error = ',f10.5)
c
      leqsym=lt
      do i=1,n1/2
       leqsym=leqsym.and.(abs(rlat(i,1)+rlat(n1-i+1,nstep)).lt.0.001
     * .and.iko(i).eq.iko(n1-i+1).and.(abs(ra(i,1)-ra(n1-i+1,nstep)).lt.
     *  0.1))
       if (lf) write(*,901)i,leqsym,rlat(i,1),rlat(n1-i+1,1)
 901   format(' i,lsy,rlat,rlat1 ',i3,l2,2f8.4)
      end do
      if (leqsym) write(*,*)' Data symmetric around Equator '
c
      if (lallme) write(*,*)' All values are mean values '
      if (lmean) then
c establishing tables of sines and cosines for mean covariance computation.
       do i=1,n*nstepi
        cclon(i)=cos((i-1)*ddlon)
        sslon(i)=sin((i-1)*ddlon)
c       write(*,*)i,cclon(i)
       end do
      end if
c     
      write(*,*)' grid contains ',N1,N,' points '
      if (n.gt.maxgrid.or.n1.gt.maxgrid) then
       write(*,*)' grid too large '
       stop
      end if
      nn1=n*n1
c
      do k=1,n
       rlon(k)=rlonmin+(k-1)*dlon
      end do
c
      write(*,*)' input degree of spherical harmonic expansion '
      write(*,*)' to be used for test-or comparison purpose. '
      read(*,*)NCOF
      if (ncof.gt.maxcof) then
       write(*,*)' WARNING ',ncof,' > ',maxcof,' ncof changed '
       nwarn=nwarn+1
       ncof=maxcof
      end if
c
      write(*,*)' Input name of file to hold calculated coefficients '
      read(*,*)ccoff
      write(*,*)' calculated coefficients will be output to ',ccoff
      open(4,file=ccoff)
      write(*,*)
     *' input name of file with coefficients used for comparison '
      write(*,*)' or for the generation of data. '
      read(*,'(a)')cofile
      write(*,*)' coefficients in ',cofile
      write(*,*)' read formatted (T/F) ? '
      read(*,*)lforma 
      if (lforma) then
       write(*,*)' input format e.g. (2I4,2d19.12) '
       read(*,75)forma 
  75   format(a72)
      end if
c
      open(12,file=cofile)
c initializing coefficient array.
      do i=1,(ncof+1)**2
       cof(i)=d0
      end do
c input of (unitless) coefficients of anomalous potential.
      write(*,*)' i   j    c(j)     s(j) '
 100  if (lforma) then
       read(12,forma)i,j,cc,cs
      else
       read(12,*)i,j,cc,cs
      end if
      if (i.lt.5) write(*,20)i,j,cc,cs
  20  format(2i4,2d16.8)
      cc=cc      
      cs=cs       
      if (j.eq.0) then
       cof(i**2+1)=cc
      else
       cof(i**2+2*j)=cc
       cof(i**2+2*j+1)=cs
      end if
      if (i.ne.ncof.or.j.ne.ncof) go to 100
c
      write(*,26)ncof
  26  format(' Coefficients to degree ',i5,' input.')
      close(12)
c
c initializing array with degree-variances.
      do k=1,maxd
       degv(k)=d0
      end do
c
      write(*,*)
     *' input minimum and maximal degree of degree-variances '
      read(*,*)mindeg,maxdeg
      write(*,*)mindeg,maxdeg
 48   format(' input gravity anomaly degree variances (',i4,
     *' - ',i4,') ')
      if (maxdeg.ge.maxd) then
       write(*,*)' ERROR ',maxdeg,' > ',maxd
       STOP
      end if
C
      write(*,*)
     *' input name of file with degree-variances (units mgal**2) '
      read(*,'(a)')ifile 
      write(*,*)' degree-variances input from: ',ifile
      open(15,file=ifile)
      read(15,*)(degv(k),k=mindeg+1,maxdeg+1)
      mout=maxdeg+1
      if (maxdeg.gt.23) mout=24
       write(*,*)mout,' first degree-variances (mgal**2) '
      write(*,30)(degv(k),k=1,mout)
  30  format(8d9.3)  
      cc=d0
      do K=1,maxdeg+1
       cc=cc+degv(k)
      end do
c
      write(*,96)cc,sqrt(cc)
  96  format(' Variance= ',f9.4,' mgal**2,st.dev. = ',
     *f9.4,' mgal (if data type ne 0). ',/)
c
c converting to potential degree-variances (unitless).
      deg0(1)=degv(1)
      deg0(2)=degv(1)
      do k=3,maxdeg+1
       if (lident.and.ikp.eq.0) then
        deg0(k)=degv(k)
       else
        deg0(k)= 1.0d-10*(RE**2/GM)**2*degv(k)/((k-d2)**2)
c       write(*,*)k,deg0(k)
       end if
      end do
c
      write(*,*)' input maximal degree for prediction '
      read(*,*)maxpre
      if (maxpre.gt.n/2) then
       write(*,*)' WARNING: above Nyquist-frequency'
       nwarn=nwarn+1
       if (maxpre.ge.n) then
        write(*,*)' WARNING: error if order .ge. ',n
        write(*,*)' results from full LSC solution will be output.'
        loutcc=lt
       end if
      end if
c
      write(*,*)
     *' output of error-estimate for max. degree to file ? '
      read(*,*)lerout
      if (lerout) then
       write(*,*)
     * 'input name of file to hold error-estimates '
       read(*,'(a)')erout 
       open(21,file=erout)
       write(*,*)
     * ' error estimates for degree ',maxpre,' output to ',erout
      end if
c
c open file to hold values of Legendre functions for test purposes only,
c using the subroutine lecurs.
      maxd2=ncof+1
      if (maxpre.gt.ncof) maxd2=maxpre+1
      if (ltest.and.(.not.lmean)) then
       OPEN(2,ACCESS='DIRECT',FORM='UNFORMATTED',
     * file='pnmfile',status='unknown',RECL=(maxd+1)*16)
c    * STATUS='SCRATCH',RECL=(maxd+1)*16)
c
       do j=0,maxd2
        pnm1(j)=d0
       end do
      end if
c
      do k=1,n1
c ikp is type of observation (0, 10, 11, 12, 13, 15) and i+ih is the power
c of (R/r) with which the Legendre function of degree i has to be multiplied.
c 
       ikp=iko(k)
       ih=iha(ikp)
c
       if (ltest.and.(.not.lmean)) then
        do j=1,maxd2
         write(2,rec=(k-1)*maxd2+j)pnm1
        end do
       end if
c
       if (lsphap) then
        rlatc=rlat0(k,ks)
        s=REM/(REM+hh(k))
       else
        rlatc=rlat(k,ks)            
        if (lf) write(*,902)k,ks,ra(k,ks)
 902    format(' k,ks,ra ',2i4,f11.1)
        s=RE/ra(k,ks)
       end if
       if (s.gt.d2.or.s.lt.d0) then
        write(*,*)' error in height, s= ',s
        nwarn=nwarn+1
       end if
c
       if (ltest.and.(.not.lmean)) then
        si=s**(ih-1)
        do i=0,maxd2-1
         si=si*s
         if (i.eq.0) then
          pnm(0)=d1
         else
          call lecurs(pnm,i,pi/d2-rlatc)
         end if
c 
         do j=0,i
          read(2,rec=(k-1)*maxd2+j+1)pnm1
c         if (ltest) write(*,29)i,j,(pnm1(i0),i0=0,4)
          pnm(j)=si*pnm(j)*(-1)**j
          if (j.gt.0) pnm(j)=pnm(j)*sq2
          pnm1(i)=pnm(j)
          write(2,rec=(k-1)*maxd2+j+1)pnm1
c         if (ltest) write(*,29)i,j,(pnm1(i0),i0=0,4)
c 29      format(2i3,5f8.5)
         end do
        end do
       end if
      end do
C
c chort checks for othogonality of cosine/sine series.
      if (lf) call chort(maxgrid,n,rlon)
      if (n.ge.maxgrid.and.ltest) STOP
c
      write(*,*)
      write(*,*)' Observations '
c
c initializing observation array.
      do k=1,n1
       do j=1,n
        g(j,k)=d0
       end do
      end do
c
      write(*,*)' Input observations from file ? (T/F) '
      write(*,*)' NOTE: all observations must be of the same type '
c WARNING change needed in order to accept different files
c and to check that the data-type is in agreement with grid-
c specifications !!!
      read(*,*)loinp
      if (loinp) then
       write(*,*)' Input file name '
       read(*,'(a)')obsfil
       open(9,file=obsfil)
       write(*,*)' Input number of data items and data item to be used '
       read(*,*)ndata,idata
       write(*,*)
     * ' Are coordinates geodetic corrdinates or geocentric (T/F) '
       read(*,*)lgeod
       write(*,*)lgeod
       if (ndata.gt.10) then
        write(*,*)' number of data items too large ! '
        stop
       end if
       if (.not.lgeod) write(*,*)' Geocentric coordinates expected '
       k=0
       sdat=d0
       ssdat=d0
       ki0=1
  63   read(9,*,end=64)num,rlati,rloni,hinp,(dat0(i),i=1,ndata)
       datin=dat0(idata)
c added 2003-01-31.
       if (.not.lgeod) then
c conversion to geodetic coordinates.
c here hinp is the radius vector length.
         x=hinp*cos(rlati/raddeg)
         y=d0
         z=hinp*sin(rlati/raddeg)
c conversion to geodetic latitude and ellipsoidal height.
         call TRANS(rlatg,h)
         if (abs(rlatg*raddeg-rlati).gt.0.3d0)
     *   write(*,*)' new lat ',rlatg*raddeg,rlati
c now h is the ellipsoidal height.
         rlati=rlatg*raddeg
       end if
       lchlis=lt
       if (abs(rlati-rlat0(ki0,0)*radeg).lt.1.0d-4) then
        ki=ki0
       else
        ki=1 
  59    if (abs(rlati-rlat0(ki,0)*radeg).lt.1.0d-4) then
         ki0=ki
        else
         ki=ki+1
         if (ki.gt.n1) then
          if (lchlis.and.abs(rlatold-rlati).gt.10.0) write(*,68)rlati
  68      format(' Latitude not in list ',f10.5)
          lchlis=lf
          rlatold=rlati
          nchlis=nchlis+1
          go to  63
         end if
         go to 59
        end if
       end if
c
       kj=rloni/dlod+1
       sdat=sdat+datin
       ssdat=ssdat+datin**2
       g(kj,ki)=datin
       k=k+1
       go to 63
c
  64   ssdat=(ssdat-sdat**2/k)/(k-1)
       if (ssdat.gt.d0) ssdat=sqrt(ssdat)
       sdat=sdat/k
       write(*,69)k,obsfil,sdat,ssdat
  69   format(i6,' observations input  from file ',a72,
     * /,', mean= ',d12.4,', stdv.=',d12.4)
       close(9)
       if (nchlis.gt.0) write(*,*)nchlis,' observations not used '
      else
c
c initializing variables used to check Legendre functions.
      idm=-1
      jdm=-1
      dycmax=d0
c
      do k= 1,n1
       nstep=1
       if (lmean1(k)) then
        nstep=nstepi
c calculating normalized area of mean value block.
        rj=d0
        do ks=1,nstep
         rj=rj+clat(k,ks)
        end do
       end if
       ikp=iko(k)
       fac=fc(ikp)
       ih=iha(ikp)
c
       do ks=1,nstep
        if (lf) write(*,*)k,ikp,fac,ih,ra(k,ks),clat(k,ks),slat(k,ks)
        s=RE/ra(k,ks)
        si=s**(ih-1)
c this may not be correct ! spharm multiplies with s !!
        iolda=-1
        jolda=-1
        pim0=D1
        pnmr(k,2,ks)=d1
        k0=0
        do j=0,ncof
         if (ltest.and.(.not.lmean)) read(2,rec=(k-1)*maxd2+j+1)pnm1
         if (lf) write(*,*)' j,pnm1 ',j,(pnm1(i0),i0=0,4)
         do i=j,ncof
          ycc=spharm0(slat(k,ks),clat(k,ks),ra(k,ks),i,j,lt,
     *    pnmr(k,1,ks),pnmr(k,2,ks),pnmr(k,3,ks),pnmr(k,4,ks),
     *    iolda,jolda)
          ycc=ycc*si
          if (.not.lsphap.and.ltest.and.(.not.lmean)) then
           yc=pnm1(i)*root(2*i+1)
c control of agreement between spharm and lecurs results.
           dyc=yc-ycc
           ddyc=abs(yc)
           if (abs(dyc).gt.1.0d-07*ddyc.and.ddyc.gt.1.0d-10) then
            write(*,*)' error in Pij ',i,j,yc,ycc
            nwarn=nwarn+1
            if (abs(dycmax).lt.abs(dyc)) then
             dycmax=dyc
             idm=i
             jdm=j
            end if
           end if
          end if 
          if (ikp.eq.11.or.ikp.eq.10) ycc=ycc*fac
          if (ikp.eq.12) ycc=ycc*fac*(i+d1)
          if (ikp.eq.13) ycc=ycc*fac*(i-d1)
          if (ikp.eq.15) ycc=ycc*fac*(i+d1)*(i+d2)
          k0=k0+1
          do j1=1,n
           if (j.eq.0) then
            k2=i**2+1
            gjk=ycc*cof(k2)
           else
            k2=i**2+2*j
            gjk=ycc*(cos(j*rlon(j1))*cof(k2)+
     *          sin(j*rlon(j1))*cof(k2+1))
           end if
           if (lmean1(k)) then
            dlfac=d0
            do kt=1,nstepi
c error detected 2001-07-28.
             dlfac=dlfac+cos(j*(ddlon*kt-sdlon))
            end do
            if (lf.and.k.eq.1.and.j1.eq.1) write(*,*)i,j,gjk,dlfac,
     *      g(j1,k)
            g(j1,k)=g(j1,k)+gjk*clat(k,ks)*dlfac/(rj*nstepi)          
           else
            if (lf.and.k.eq.1.and.j1.eq.1) write(*,*)i,j,gjk,g(j1,k)
            g(j1,k)=g(j1,k)+gjk
           end if
          end do
         end do
        end do
       end do
       if (lf) write(*,10)k,(g(j1,k),j1=1,n)
 10    format(' row no ',i3,/,50(7d10.2,/))
       k3=k0
       if (k0.gt.24) k3=24
c
c converting into spherical approximation.
       if (lsphap) then
        clat(k,ks)=cos(rlat0(k,ks))
        slat(k,ks)=sin(rlat0(k,ks))
        ra(k,ks)=REM+hh(k)
        fc(10)=(GM/REM)
C converting to m**2/s**2
        fc(12)=GM/REM**2*1.0d5
        fc(13)=GM/REM**2*1.0d5
c converting to mgal
        fc(11)=RE
c converting to m.
        fc(15)=1.0d9*GM/(REM**3)
c converting to EU.
       end if
      end do
      ks=1
c
      if (.not.lsphap.and.(idm.ge.0.or.jdm.ge.0)) then
       write(*,*)' maximal difference between Pij: i,j,dif= ',
     * idm,jdm, dycmax
      end if
c
      end if
c
      if (.not.loinp) then
      write(*,*)' Output of observations to file (T/F) '
      read(*,*)loout
       if (loout) then
        write(*,*)' Input file name '
        read(*,'(a)')obsfil
        open(19,file=obsfil)
        do k=1,n1
         rlat1=rlat0(k,0)*radeg
         do j=1,n
c output coordinates are geodetic latitude, longitude and ellipsoidal
c height.
          rlon1=(rlonmin+(j-1)*dlon)*radeg
          i=(k-1)*n1+j
          write(19,58)i,rlat1,rlon1,hh(k),g(j,k)
   58     format(i6,2f10.4,f10.1,d13.5)
         end do
        end do
        write(*,*)' Observations output to file ',obsfil
        close(19)
       end if
      end if
C
      ss=d0
      i=0
      do k=1,n1
       do j=1,n
        ss=ss+g(j,k)**2
        i=i+1
        if (i.le.maxobs) rh(i)=g(j,k)
       end do
      end do
      write(*,73)ss/(n*n1)
   73 format(' variance of observations = ',d15.5)
c
      write(*,*)' Observation calculation/input completed '
      call fdate(udate)
      write(*,*)udate
      if (lsphap) then
       RE=REM
      end if
      ikold=-1
      ik1old=-1
c
      lnocc=n*n1.gt.maxgrid 
      loutcc=lt
      if (lnocc) then
       write(*,*)' no full collocation solution, n*n1= '
     * ,n*n1
      else
       write(*,*)' Full collocation solution, n*n1= '
     * ,n*n1
      end if
      if (lnocc) go to 1000
c
c setting up the collocation normal-equations with a full matrix.
      K0=1
      i=1
      j=1
      do k=1,n1*n
       ik=iko(i)
       ih=iha(ik)
       fac=fc(ik)
c
       clati=clat(i,ks)
       slati=slat(i,ks)
       rlonj=rlon(j)
       rai=ra(i,ks)
       s=RE/rai
c
       j1=1
       m=1
       do k1=1,k
        ik1=iko(j1)
        ih1=iha(ik1)
        fac1=fc(ik1)
c
        if (ik.ne.ikold.or.ik1.ne.ik1old) then
c change unitless potential degree-variances to degee-variances
c of actual data-combination.
         ss=d0
         do i1=0,maxdeg
          fac2=d1
          if (ik.eq.12) fac2=fac2*(i1+d1)
          if (ik.eq.13) fac2=fac2*(i1-d1)
          if (ik1.eq.12) fac2=fac2*(i1+d1)
          if (ik1.eq.13) fac2=fac2*(i1-d1)
          if (ik.eq.15) fac2=fac2*(i1+d1)*(i1+d2)
          if (ik1.eq.15) fac2=fac2*(i1+d1)*(i1+d2)
          degv(i1+1)=deg0(i1+1)*fac*fac1*fac2
          ss=ss+degv(i1+1)
         end do
         if (ltest) then
          write(*,70)ik,ik1,ss
   70     format(' degree-variances changed, type=  ',2i4,
     *    ', new variance= ',f12.6)
          write(*,30)(degv(j4),j4=1,24)
         end if
         ikold=ik
         ik1old=ik1
        end if
c
        if (lmean1(i).or.lmean1(j1)) then
         n1s=n1/2
c        ltestc=ltest.and.i.eq.n1s.and.j1.eq.n1s.and.m.lt.4
         ltestc=ltest.and.icout.lt.2
         c(k0)=cmean(dlon,maxdeg,ih,ih1,i,j,j1,m,n,ltestc)
         icout=icout+1
        else
         clatj=clat(j1,1)
         slatj=slat(j1,1)
         rlonm=rlon(m)
         t=slati*slatj+clati*clatj*cos(rlonj-rlonm)
         if (lf) write(*,60)i,j,j1-1,m,t
  60     format(4i3,f10.5)
c WARNING  no Bjerhammar-sphere radius in use !!
         s1=RE/ra(j1,ks)
         c(k0)=cov(maxdeg,degv,t,ih,ih1,s,s1)
        end if
c
        ssdegx=d0
        do issd=1,maxdeg+1
         ssdegx=ssdegx+degv(issd)
        end do
        if (k1.eq.k) then
        c(k0)=c(k0)+sno(j1)**2
        if (lf) write(*,72)k0,c(k0),sno(j1)  
  72    format(' k0,c,sno ',i4,2d15.7)
c       write(*,*)' ssdeg= ',ssdegx
        end if
        if (m.eq.n) then
         m=1
         j1=j1+1
        else
         m=m+1
        end if
c
        k0=k0+1
       end do
       if (j.eq.n) then
        j=1
        i=i+1
       else
        j=j+1
       end if
      end do
      if (maxc.lt.2011.or.ltest) then
       write(*,*)' NEQ, k=1,20 '
       write(*,50)(C(K),k=1,20)
  50   format(5d14.6) 
      end if
c
      call PRONLL(c,izero,rh,nn1,var,lt,lt,maxcc,maxobs,maxobs)
      write(*,*)
      if (maxc.lt.2011.or.ltest) then
       write(*,*)' Reduced matrix: (k=1,20) '
       write(*,50)(C(K),k=1,20)
      end if
      write(*,95)var,ss
  95  format(' Weighted square sua of obs and sq. sua= ',2d14.5,/)
      if (maxc.lt.2011.or.ltest) then
       write(*,*)' Solutions: (k=1,20) '
       write(*,50)(rh(k),k=1,20)
      end if
C
C check 1 solution by predicting back in point (1,1)
      pred=d0
      k=0
      ikp=iko(1)
      fac=fc(ikp)
      ih=iha(ikp)
      s=RE/ra(1,ks)
      ik1old=-1
      do i=1,n1 
       ik1=iko(i)
       fac1=fc(ik1)
       ih1=iha(ik1)
       s1=RE/ra(i,ks)
       do j=1,n
        k=k+1
c WARNING  no Bjerhammar-sphere radius in use !!
c
        if (ik1.ne.ik1old) then
c change unitless potential degree-variances to degee-variances
c of actual data-combination.
         do i1=0,maxdeg
          fac2=d1
          if (ik.eq.12) fac2=fac2*(i1+d1)
          if (ik.eq.13) fac2=fac2*(i1-d1)
          if (ik1.eq.12) fac2=fac2*(i1+d1)
          if (ik1.eq.13) fac2=fac2*(i1-d1)
          if (ik.eq.15) fac2=fac2*(i1+d1)*(i1+d2)
          if (ik1.eq.15) fac2=fac2*(i1+d1)*(i1+d2)
          degv(i1+1)=deg0(i1+1)*fac*fac1*fac2
          if (lf) write(*,*)' degv ',i1,degv(i1+1)
          ik1old=ik1
         end do
        end if
c
        if (lmean1(1).or.lmean1(i)) then
         c0=cmean(dlon,maxdeg,ih,ih1,1,1,i,j,n,lf)  
        else
         t=slat(1,1)*slat(i,1)+clat(1,1)*clat(i,1)
     *   *cos(rlon(1)-rlon(j))
         c0=cov(maxdeg,degv,t,ih,ih1,s,s1)
        end if
        if (lf) write(*,79)i,j,t,c0
  79    format(2i3,2d12.5)
        pred=pred+c0*rh(k)
       end do
      end do
      if (abs(pred-g(1,1)).gt.(1.0d-8+sno(1))) then
       write(*,65)pred,g(1,1),pred-g(1,1)
  65   format(' Error in prediction in point 1: ',3d12.5,/)
       nwarn=nwarn+1
      end if
      icout=0
c
      write(*,*)' Full collocation solution completed '
      call fdate(udate)
      write(*,*)udate
C prediction of coefficients
      write(*,*)
     *' Prediction of coefficients and their error-estimates.'
      if (ltest) write(*,*)
     *' degree order predicted  observed       error '
c
      ncof=maxpre
c
c initializing for call of spharm0.
      do k=1,n1
       do ks=1,nstep
c suspected error 2002-11-06
c      do ks=1,nstepi
        pnmr(k,2,ks)=d1
        nolda(k,ks)=-1
        molda(k,ks)=-1
       end do
      end do
c
      do m1=0,ncof
c
       do n2=m1,ncof  
        degn2=sqrt(degv(n2+1)*deg0(n2+1))
        if (lf) write(*,*)' degn2 ',degn2,n2+1,deg0(n2+1)
        n3=2
        if (m1.eq.0) n3=1
        m=m1
        icout=0
        do n4=1,n3
         if (n4.eq.2) m=-m
C first predicting using (obs*C*-1)*cov(obs,cof).
         pred=d0
         k=0
         do j=1,n1
          if (ltest.and.(.not.lmean))
     *    read(2,rec=(j-1)*maxd2+m1+1)pnm1
          if (lmean1(j)) then
           nsteps=nstepi
          else
           nsteps=1
          end if
c
          ycs=d0
          if (n4.eq.1) then  
           rji=d0
           do ks=1,nsteps
            rji=rji+clat(j,ks)
            yc=spharm0(slat(j,ks),clat(j,ks),ra(j,ks),n2,m1,lt,
     *      pnmr(j,1,ks),pnmr(j,2,ks),pnmr(j,3,ks),pnmr(j,4,ks)
     *      ,nolda(j,ks),molda(j,ks))
c error 2003-08-21
            ipk=iko(j)
ceeeeeeeeeeeih=iha(ikp)
            ih=iha(ipk)
            s=RE/ra(j,ks)
            si=d1    
            si=s**(ih-1)
c corr  20/4si=s**(ih-1)
            yc=yc*si/root(2*n2+1)
            pnmr(j,5,ks)=yc
            if (ltest.and.(.not.lmean)) then
             ycc=pnm1(n2)
             if (abs(yc-ycc).gt.1.0d-10) write(*,74)n2,m,ih,s,yc,ycc
   74        format(' error 0 ',3i3,3f12.7)
            end if
            if (lmean1(j)) then
C weighting with respect to cosine latitude for mean values.
             ycs=ycs+yc*clat(j,ks)
            else
             ycs=ycs+yc
            end if
           end do
          else
           if (lmean1(j)) then
            rji=d0
            do ks=1,nsteps
C weighting with respect to cosine latitude for mean values.
             ycs=ycs+pnmr(j,5,ks)*clat(j,ks)
             rji=rji+clat(j,ks)
            end do
           else
            ycs=ycs+pnmr(j,5,1)
           end if
c          if (icout.lt.18) write(*,*)' pmnr ',pnmr(j,5,1),k,j
          end if
          do i=1,n
           k=k+1
           if (lmean1(j)) then
            dlfac=d0
            do kt=1,nstepi
             dlfac=dlfac+cos(m1*(ddlon*kt-sdlon))
            end do
            nsteps=nstepi
           else
            dlfac=d1
            nsteps=1
           end if
c          write(*,*)' X ',degn2,n2,pnm1(n2),root(2*n2+1),rlon(i)
           if (m.ge.0) then
c           cc0=pnm1(n2)*cos(m*rlon(i))*degn2/root(2*n2+1)
            if (lmean1(j)) then
C weighting with respect to cosine latitude for mean values.
             cc0=ycs/rji*cos(m*rlon(i))*degn2/root(2*n2+1)*
     *       dlfac/nsteps
            else
             cc0=ycs*cos(m*rlon(i))*degn2/root(2*n2+1)
            end if
            if (icout.lt.4.and.ltest.and.m.eq.3) then
             write(*,101)
     *       i,cc0,ycs,rji,dlfac,degn2,cos(m*rlon(i))
 101         format(' icc0-cycsrji ',i3,3d14.4,/,3d14.5)
             icout=icout+1
            end if
c           write(*,*)' XX ',j,i,k,ycs,cc0
           else
c           cc0=pnm1(n2)*sin(abs(m)*rlon(i))*degn2/root(2*n2+1)
            if (lmean1(j)) then
C weighting with respect to cosine latitude for mean values.
             cc0=ycs/rji*sin(abs(m)*rlon(i))*degn2/root(2*n2+1)*
     *       dlfac/nsteps
            else
             cc0=ycs*sin(abs(m)*rlon(i))*degn2/root(2*n2+1)
            end if
            if (icout.lt.19.and.ltest.and.abs(m).eq.3) then
             write(*,102)
     *       i,cc0,ycs,rji,dlfac,degn2,sin(abs(m)*rlon(i))
 102         format(' icc0-sycsrji ',i3,3d14.4,/,3d14.5)
             icout=icout+1
            end if
c           write(*,*)' YY ',j,i,k,ycs,cc0
           end if
           rc(k)=cc0
 35        format(' 35 ',3i3,6d11.3)
           pred=pred+cc0*rh(k)
           if (abs(m).eq.3.and.ltest.and.icout.lt.19)
     *     write(*,35)j,i,m,cc0,rh(k),degn2,pnm1(n2),
     *     rlon(i),pred
          end do
         end do
c
c error-estimation.
        call PRONLL(c,izero,rc,nn1,var,lf,lt,maxcc,maxobs,maxobs)
        if (lf) then
         write(*,91)(rc(II),ii=1,nn1)
        end if
c predicting using (cov(obs,cof))*C**-1)*obs.
        suaa=d0
        ii=1
        do kb=1,n1
         do ka=1,n
          suaa=suaa+rc(ii)*g(ka,kb)
          ii=ii+1
         end do
        end do
 91     format(5f12.6)
        if (abs(pred-suaa).gt.1.0d-13) write(*,81)pred,suaa
 81     format(' inconsistency pred,suaa= ',2d15.7)
c
        err0=deg0(n2+1)/(d2*n2+d1)
        err2=err0-var
        if (err2.gt.d0) err2=sqrt(err2)
c
c finding subscript of coefficient in array cof.
        if (m.eq.0) then
         k3=n2**2+1
        else
         if (m.gt.0) then
          k3=n2**2+2*m
         else
          k3=n2**2-2*m+1
         end if
        end if
c
        if (abs(m).eq.3.and.ltest.and.icout.lt.19) then
         write(*,15)n2,m,pred,cof(k3),err2,sqrt(err0)
  15     format(2i4,4D14.6)
         icout=icout+1
        end if
        if (k3.lt.31**2) then
         cofr(k3,1)=pred
         cofr(k3,2)=err2
        end if
c
        end do
       end do
      end do
c
      write(*,*)
     *' Full collocation prediction and error-estimation completed. '
c
      write(*,*)
      call fdate(udate)
      write(*,*)udate
C
cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
c
 1000 ikold=-1
      ik1old=-1
      icout=0
      cvmin=1.0d10
      cvmax=d0
c
      write(*,*)' Will covariances be input from file (T/F) ?'
      read(*,*)lincov
      if (lincov) then
       write(*,*)' input name of file '
       read(*,'(a)')covfil
       write(*,*)' covariances input from ',covfil
      else
       write(*,*)' covariances will be stored in file covsph '
       covfil='covsph'
      end if
c the file will contain the covariances.
      OPEN(3,ACCESS='DIRECT',FORM='UNFORMATTED',
     *file=covfil,status='unknown',RECL=(nd2+1)*16)
c
      if (leqsym) then
c if we have symmetry around equator, the covariances will be
c identical for the same symmetric latitude pairs. 2001-07-18.	
       n1s=n1/2
       if (n1s*2.ne.n1)n1s=n1s+1
       write(*,*)n1s,' parallels used ' 
      else
       n1s=n1
      end if
c
      do k=1,n1
c initializing variables for re-use of spharm0.
       do ks=1,nstepi
        pnmr(k,2,ks)=d1
        nolda(k,ks)=-1
        molda(k,ks)=-1
       end do
      end do
c
      if (lincov) go to 1600
c variables to register variances initialized.
      do k=0,25
       cv(k)=d0
       sscv(k)=d0
       nc(k)=0
      end do
c
      do k=1,n1s
       ik=iko(k)
       ih=iha(ik)
       fac=fc(ik)
       s=RE/ra(k,1)
c
       do k1=1,n1
        ik1=iko(k1)
        ih1=iha(ik1)
        fac1=fc(ik1)
        s1=RE/ra(k1,1)
        do i=0,nd2
         if (ik.ne.ikold.or.ik1.ne.ik1old) then
c change unitless potential degree-variances to degee-variances
c of actual data-combination.
          if (ltest) write(*,*)' degree-variances changed ',ik,ik1
          ss=d0
          do i1=0,maxdeg
           fac2=d1
           if (ik.eq.12) fac2=fac2*(i1+d1)
           if (ik.eq.13) fac2=fac2*(i1-d1)
           if (ik1.eq.12) fac2=fac2*(i1+d1)
           if (ik1.eq.13) fac2=fac2*(i1-d1)
           if (ik.eq.15) fac2=fac2*(i1+d1)*(i1+d2)
           if (ik1.eq.15) fac2=fac2*(i1+d1)*(i1+d2)
           degv(i1+1)=deg0(i1+1)*fac*fac1*fac2
           ss=ss+degv(i1+1)
          end do
          ikold=ik
          ik1old=ik1
          if (ltest) then
           write(*,70)ik,ik1,ss
           write(*,30)(degv(j4),j4=1,24)
          end if
         end if
c
c        ltestc=ltest.and.leqsym.and.k.eq.n1s.and.k1.eq.n1s.and.i.lt.3
         ltestc=ltest.and.icout.lt.2
         if (lmean1(k).or.lmean1(k1)) then
c addition 2001-07-25.
          c(i+1)=cmean(dlon,maxdeg,ih,ih1,k,1,k1,i+1,n,ltestc)
          icout=icout+1
         else
C changed 2001-05-15.
c t is cosine of the spherical distance.
          t=slat(k,1)*slat(k1,1)+clat(k,1)*clat(k1,1)*cos(dlon*i)
          if (ltest.and.i.eq.0.and.ik.eq.1.and.ik1.eq.1)
     *    write(*,903)s,s1,ih,ih1,t
 903      format(' ss1ihih1,t,c ',2f9.6,2i4,f10.6,d15.7)
          if (lf.and.k.eq.1.and.k1.eq.1.and.i.lt.2)
     *    write(*,*)' t ',slat(k,1),slat(k1,1),clat(k,1),
     *    clat(k1,1),cos(dlon*i)
c
          c(i+1)=cov(maxdeg,degv,t,ih,ih1,s,s1)
          if (ltestc) write(*,903)s,s1,ih,ih1,t,c(i+1)
         end if
c
         if (i.eq.0.and.k.eq.k1) then
          nc(ik1)=nc(ik1)+1
          cv(ik1)=cv(ik1)+c(i+1)
          sscv(ik1)=sscv(ik1)+c(i+1)**2
          if (cvmin.gt.c(i+1)) cvmin=c(i+1)
          if (cvmax.lt.c(i+1)) cvmax=c(i+1)
c         write(*,*)'cvmin,max,c ',cvmin,cvmax,c(i+1)
         end if
        end do
c
        if (leqsym.and.k.eq.n1s.and.k1.eq.n1s) then
c output of covariance function close to Equator. 2001-07-25.
         open(16,file='sphcovtab')
         do i5=0,nd2
          write(16,52)i5*dlod,c(i5+1)
  52      format(f8.2,d16.5)
         end do
         close(15)
         write(*,*)' covariances output to sphcovtab '
        end if
c
        write(3,rec=(k-1)*n1+k1)(c(i5+1),i5=0,nd2)
c
        if (lf.and.k.lt.4) write(*,47)k,k1, (c(i5),i5=1,5)
  47    format(' cov1 ',2i4,5f12.6)
c 
        nnarr(1)=n
        nnarr(2)=0
        if (ltest) then
c       call fourt(c,nnarr,1,-1,0,wrk,idim2,iwkdim)
        if (lf) write(*,43)k,k1,(c(i),i=1,5)
  43    format(' k,k1,c1-5 ',2i3,/,50(5d14.6,/))
        end if
       end do
       if (ltest) write(*,*)' cov stored ',k
      end do
c
      write(*,*)' Calculation of covariances and storage completed '
      call fdate(udate)
      write(*,*)udate
      write(*,*)
      write(*,*)' Covariance type, number, mean and standard-deviation '
      do i=0,25
       if (nc(i).gt.0) then
        if (nc(i).gt.2) sscv0=sqrt((sscv(i)-cv(i)**2/nc(i))/(nc(i)-1))
        write(*,44)i,nc(i),cv(i)/nc(i),sscv0
  44    format(2i4,2d12.4)
       end if
      end do
      write(*,99)cvmin,cvmax
   99 format(' min, max variance= ',2d12.4)
 1600 write(*,*)' '
c
      write(*,*)
     *' Prediction of coefficients using compact formulae.'
      write(*,*)' Output coefficients and differences ? (T/F) '
      read(*,*)ldiout
      if (ldiout) then
       write(*,*)
     * ' i    j    prediction  error-est. observed coll.est.  coll.err.'
      else
       write(*,*)' Coefficients output to ',ccoff
      end if
c
c initializing variables to hold summary of prediction result.
      ncof=maxpre
      do ip=0,ncof
       do iq=1,6
        sdeg(ip,iq)=d0
        ssdeg(ip,iq)=d0
       end do
c initialized to hold max and min of differences obs-pred. and
c error estimates.
       sdeg(ip,7)=1.0d10
       sdeg(ip,8)=-1.0d10
       ssdeg(ip,7)=1.0d10
       ssdeg(ip,8)=-1.0d10
      end do
      nerror=0
c
      do m=0,ncof     
c 
       k=0
c i counts the parallels.
       do i=1,n1
        if (maxd2.lt.60.and.ltest) read(2,rec=(i-1)*maxd2+m+1)pnm1
        do j=1,i
c change 2001-07-19.
         if (leqsym.and.i.gt.n1s) then
          irec=(n1-i)*n1+n1-j+1
         else
          irec=(i-1)*n1+j
         end if
c
         read(3,rec=irec)(covf(j5+1),j5=0,nd2)
         if (lf) write(*,*)' cov0 ',irec,covf(1),covf(2)
         if (lf.and.i.lt.4.and.j.lt.4)
     *    write(*,*)' cov2 ',i,j, (c(i5),i5=1,5),irec,nd2
c        if (m.le.2) write(*,*)' read 3 ',i,j
c evaluating Ref. eq. (36), thereby calculating Gamma-tilde, m, ij.
         g0mij=d0
         do i5=0,n-1
          if (i5.le.nd2) then
           covff=covf(i5+1)
          else
           covff=covf(n-i5+1)
          end if
          g0mij=g0mij+covff*cos(dlon*i5*m)
         end do
         g0mij=d2*g0mij/n
         if (m.eq.0) g0mij=g0mij/d2
c 
         c(k+1)=g0mij
         if (i.eq.j) then
          if (m.eq.0) then
c adding noise variance contribution to normal equations, cf. Ref.
c eq. (26).
           c(k+1)=c(k+1)+sno(i)**2/n
          else
           c(k+1)=c(k+1)+d2*sno(i)**2/n
          end if
         end if
         k=k+1
        end do
       end do
       if (ltest.and.m.le.1) write(*,90)k,(c(k1),k1=1,5)
  90   format(i6,/,800(6d10.4,/))
       do i=1,n1
        rh(i)=d0
       end do
c
       n11=n1
c calculating the reduced Cholesky matrix of Ref. eq. (22).
       call PRONLL(c,izero,rh,n11,var,lt,lf,maxcc,maxobs,maxobs)
       if (ltest) then
        write(*,*)' Reduced matrix (1-5) '
        write(*,97)(c(k1),k1=1,5)
       end if
c
       do n2=m,ncof
        do i=1,n1
c i counts the parallels.
         if (ltest.and.(.not.lmean)) then
          read(2,rec=(i-1)*maxd2+m+1)pnm1
          ycc=pnm1(n2)
         end if
         ipk=iko(i)
         ih=iha(ipk)
C change (addition) 2003-06-17.
         if (ipk.ne.ikold.or.ipk.ne.ik1old) then
          fac1=fc(ipk)
          do i1=0,maxdeg
           fac2=d1
           if (ipk.eq.12) fac2=fac2*(i1+d1)**2
           if (ipk.eq.13) fac2=fac2*(i1-d1)**2
           if (ipk.eq.15) fac2=fac2*((i1+d1)*(i1+d2))**2
           degv(i1+1)=deg0(i1+1)*(fac1**2)*fac2
          end do
          ikold=ipk
          ik1old=ipk
         end if
         degn2=sqrt(deg0(n2+1)*degv(n2+1))
         if (lf) write(*,*)n2,degn2,deg0(n2+1),degv(n2+1)
         if (lmean1(i)) then
          nsteps=nstepi
         else
          nsteps=1
         end if
c
c        if (leqsym.and.n2.gt.n1s) then
c preparation for the use of Pnn(sinphi)=Pnm(-sinphi) n even and
c = -Pnm(sinphi) n odd.
c        end if
c
         ycs=d0
         rji=d0
         do ks=1,nsteps
          rji=rji+clat(i,ks)
          yc=spharm0(slat(i,ks),clat(i,ks),ra(i,ks),n2,m,lt,
     *    pnmr(i,1,ks),pnmr(i,2,ks),pnmr(i,3,ks),pnmr(i,4,ks),
     *    nolda(i,ks),molda(i,ks))
          s=RE/ra(i,ks)
          si=s**(ih-1)
          yc=yc*si
c covariance between coefficient and observation, cf. Ref. eq. (6).
          ycs=ycs+yc*clat(i,ks)
         end do
         if (ltest.and.(.not.lmean).and.
     *   abs(yc/root(2*n2+1)-ycc).gt.1.0d-10)
     *   write(*,*)' error 1 ',n2,m,yc,ycc
         rh(i)=ycs*degn2/((d2*n2+d1)*rji) 
         rc(i)=rh(i)
        end do
        if (ltest) write(*,97)(rh(k1),k1=1,5)
c Cholesky reduction of Ref. eq. (22), right hand side.
        call PRONLL(c,izero,rh,n1,var,lf,lt,maxcc,maxobs,maxobs)
        if (lf) then
         write(*,98)n2,m
c the quantities delta of Ref. eq. (22) are stored in the array rh.
  98     format(' Solutions delta(',i4,',',i4,')')
         write(*,97)(rh(k1),k1=1,n1)
  97     format(' rh1-5 ',6d10.4)
        end if
c
        m4=2
        if (m.eq.0) m4=1
c
        fact=d1/n
        if (m.ne.0)  fact=fact*d2
c
        do m3=1,m4
         lsin=m3.eq.2   
         sua=d0
         ssua=d0
         do j=1,n1
c j runs over parallels.
          do i=1,n
           if (lsin) then
            enlon=sin(m*rlon(i))
           else
            enlon=cos(m*rlon(i))
           end if
           if (lmean1(j)) then
c error detected 2003-07-30.
            dlfac=d0
            do kt=1,nstepi
             dlfac=dlfac+cos(m*(ddlon*kt-sdlon))
            end do
            nsteps=nstepi
           else
            dlfac=d1
            nsteps=1
           end if
c cf. Ref. eq. (23).
           ci=rc(j)*enlon*dlfac/nsteps
           s1=rh(j)*enlon*fact*dlfac/nsteps
           if (ltest.and.i.eq.9.and.nwarn.lt.4.and.n2.eq.m)
     *     write(*,87)j,nsteps,s1,g(i,j),dlfac
  87       format(' jnst, rh*enlon*fact, g(i,j) dlfac ',2i3,3d15.4)
c calculating the sums of Ref. eq. (24) and (25).
           sua=sua+s1*g(i,j)
           ssua=ssua+s1*ci
          end do
         end do
c
         ma=m
         if (lsin) ma=-m
         if (m.eq.0) then
          k3=n2**2+1
          cnm=sua
c cf Ref. eq.(25).
          error=deg0(n2+1)/(2*n2+d1)-ssua
          if (error.ge.d0) then
           ecnm=sqrt(error) 
          else
           ecnm=error
           if (error.lt.-0.1D-20) then 
            write(*,443) n2,m,ssua,error
 443        format(' warning: error wrong ',2i3,3d15.5)
            nwarn=nwarn+1
           end if
          end if
          snm=d0
          esnm=d0
          write(4,444)n2,m,cnm,snm,ecnm,esnm
 444      format(2i4,4d20.12)
         else
          if (ma.ge.0) then
           k3=n2**2+2*m
           cnm=sua
           error=deg0(n2+1)/(2*n2+d1)-ssua
           if (error.gt.d0) then
            ecnm=sqrt(error) 
           else
            ecnm=error
            if (error.lt.-0.1D-20) then 
             write(*,443) n2,m,ssua,error
             nwarn=nwarn+1
            end if
           end if
          else
           k3=n2**2-2*ma+1
           snm=sua
           error=deg0(n2+1)/(2*n2+d1)-ssua
           if (error.ge.d0) then
            esnm=sqrt(error) 
           else
            if (error.lt.-0.1D-20) then 
             write(*,443) n2,m,ssua,error
             nwarn=nwarn+1
            end if
           end if
           write(4,444)n2,-ma,cnm,snm,ecnm,esnm
          end if
         end if
c
         error=deg0(n2+1)/(2*n2+d1)-ssua
         if (error.gt.0.0d-25) error=sqrt(error)
         if (lerout.and.n2.eq.maxpre) ersum(ma)=error
c
         if (k3.lt.31**2.and.(.not.lnocc)) then
          dsum=abs(sua)+abs(cofr(k3,1))
          ddsum=abs(error)+abs(cofr(k3,2))
          if (abs(sua-cofr(k3,1)).gt.dsum*1.0d-4.and.
     *    abs(error-cofr(k3,2)).gt.ddsum*1.0d-4) then
           write(*,14)n2,ma,sua,error,cof(k3),cofr(k3,1),cofr(k3,2)
  14       format(i4,i5,5d13.5)
           nerror=nerror+1
          else
           if (ltest)
     *     write(*,14)n2,ma,sua,error,cof(k3),cofr(k3,1),cofr(k3,2)
           write(*,16)n2,ma,sua,error,cof(k3)
  16       format(i4,i5,3d13.5, '  agrees ')
          end if
         else
          if (ldiout)
     *    write(*,14)n2,ma,sua,cof(k3),sua-cof(k3),error
         end if
         cdif=sua-cof(k3)
         sdeg(n2,1)=sdeg(n2,1)+sua
         sdeg(n2,2)=sdeg(n2,2)+cdif
         sdeg(n2,3)=sdeg(n2,3)+error
         ssdeg(n2,1)=ssdeg(n2,1)+sua**2
         ssdeg(n2,2)=ssdeg(n2,2)+cdif**2
         ssdeg(n2,3)=ssdeg(n2,3)+error**2
         if (.not.lnocc) then
          sdeg(n2,4)=sdeg(n2,4)+sua-cofr(k3,1)
          ssdeg(n2,4)=ssdeg(n2,4)+(sua-cofr(k3,1))**2
          sdeg(n2,5)=sdeg(n2,5)+cofr(k3,1)-cof(k3)
          ssdeg(n2,5)=ssdeg(n2,5)+(cofr(k3,1)-cof(k3))**2
         end if
         if (sdeg(n2,7).gt.cdif) sdeg(n2,7)=cdif
         if (sdeg(n2,8).lt.cdif) sdeg(n2,8)=cdif
         if (ssdeg(n2,7).gt.error) ssdeg(n2,7)=error
         if (ssdeg(n2,8).lt.error) ssdeg(n2,8)=error
        end do
       end do
      end do
c
      write(*,*)
      write(*,*)' Comparison observed-predicted '
      if (lnocc) then
       if (lt00) then
        write(*,*)' degree mean      S.D.        S.D.  mean error '
       else
        write(*,*)' multiplied by 1.0d10 '
        write(*,76)
   76   format(' deg.  mean    min     max    S.D. '
     *  ,' mean error min    max    sqrt(dgv) ')
       end if
       nout=3
      else
       write(*,*)
     * '          Compact              Tra          Tra.-Comp.  '
       write(*,71)
  71   format(' deg    mean        S.D.         S.D. ',
     * '      S.D.      mean err.  deg. stdv. ')
       nout=5
      end if
c
      do n2=2,ncof
       do j=1,nout
        ssdeg(n2,j)=((ssdeg(n2,j)-sdeg(n2,j)**2/(2*n2))/(2*n2+1))
        if (ssdeg(n2,j).gt.1.0d-55) ssdeg(n2,j)=sqrt(ssdeg(n2,j))
        sdeg(n2,j)=sdeg(n2,j)/(2*n2+1)
       end do
       cvari=sqrt(deg0(n2+1)/(2*n2+1))
       if (lnocc) then
        if (lt00) then
         write(*,89)n2,sdeg(n2,2),ssdeg(n2,2),sdeg(n2,3),cvari
  89     format(i4,6d12.4)
        else
         d10=1.0d10
         write(*,77)n2,sdeg(n2,2)*d10,sdeg(n2,7)*d10,
     *   sdeg(n2,8)*d10,ssdeg(n2,2)*d10,sdeg(n2,3)*d10,
     *   ssdeg(n2,7)*d10,ssdeg(n2,8)*d10,cvari*d10
  77     format(i4,8f8.4) 
        end if
       else
        write(*,89)n2,sdeg(n2,2),ssdeg(n2,2),ssdeg(n2,5),
     *  ssdeg(n2,4),sdeg(n2,3),cvari
       end if
      end do
c
      if (.not.lnocc) write(*,*)' number of disagreements = ',nerror
c
      if (nwarn.gt.0) then
       write(*,*)' number of warnings = ', nwarn
      end if
c
      if (lerout) then
       do k=-ncof,ncof
        write(21,78)k,ersum(k)
 78     format(i5,d16.7)
       end do
       close(21)
      end if
c
      close(2)
      close(3)
      close(4)
      close(15)
c
      write(*,*)' End of program sphgrid '
      call fdate(udate)
      write(*,*)udate
c
      stop

      end
c
      double precision function cov(maxdeg,degv,t,ih,ih1,s,s1)
c covariance function evaluation.
c maxdeg = maximal degree of Legendre expansion of covariance function.
c degv   = array holding degree-variances.
c t      = cosine (spherical distance)
c ih     = the degree+ih is the power of the square of the ratio
c          between the Bjerhammar sphere and the radial distance.
c r      = the square of the ratio of the Bjerhammar-sphere radius and the
c          radial distance.
C 
c     implicit real*8 (a-h,o-z),logical(l)
      implicit none
      logical lf,lt,ltest
      integer maxd,ih,ih1,n,maxdeg
      parameter (maxd=1800)
      real*8 D0,D1,D2,D3,D4,D5,RE,RADDEG,PI,GM,s,s1,t,
     *r,s2,st,x2,x1,dn,c1,c2,x0,degv
c
      COMMON /DCON/D0,D1,D2,D3,D4,D5,RE,RADDEG,PI,GM,LTEST,LF,LT
      dimension degv(maxd)
c
      R=s*s1
      S2=R**2
      ST=R*T
      X2=D0
      X1=D0
c using clenshaw summation.
      DO 40, N=MAXDEG,0,-1
       DN=DBLE(N)
       C1=-(D2*DN+D1)/(DN+D1)*ST
       C2=S2*(DN+D1)/(DN+D2)
       X0=-C1*X1-C2*X2+degv(N+1)
       X2=X1
       X1=X0
  40  CONTINUE
      X0=X0*s**ih*s1**ih1
C
      cov=X0
      return
      end
c
      double precision function cmean(dlon,maxdeg,ih,ih1,i,j,j1,m,n,
     *ltestc)
c the function calculates covariances of mean values of equal-area
c blocks with side-length dlon (radians).
c programmed 2001-05-17 by C.C.Tscherning. Last update: 2001-07-26.
c       
c     implicit real*8 (a-h,o-z),logical (l)
      implicit none
      integer maxgrid,maxcof,maxd,maxobs,nstepi,nc,izero,i,j1,
     *nsteps,nstept,ks,j,kj,km,m,nm,n,iha,iko,maxdeg,ih,
     *molda,nolda,ih1,kt,nm0
      parameter (maxgrid=4050,maxcof=360,maxd=1800,maxobs=720*360,
     *nstepi=3) 
c mstepi is the number of steps in the numerical integration of mean
c values.
c
      logical ltest,ltestc,lt,lf,lmean1,lmean
      real*8 D0,D1,D2,D3,D4,D5,RE,RADDEG,PI,GM,
     *cofr,rlat,rlat0,clat,slat,rlon,clon,slon,
     *ra,hh,g,covf,c,rh,degv,deg0,sno,rc,pnm,pnm1,sdeg,
     *pnmr,ersum,ssdeg,fc,sscv,cv,cof,sslon,cov,rlonm,cclon,
     *t,cdlon,s1,slatj,clatj,rlonj,s,rai,slati,clati,
     *c0,rji,ddlonj,sdlonj,ddloni,dlon,sdloni

c
      COMMON /DCON/D0,D1,D2,D3,D4,D5,RE,RADDEG,PI,GM,LTEST,LF,LT
      common /ww/cof((maxcof+1)**2),cofr(31**2,2),
     *rlat(maxgrid,nstepi),rlat0(maxgrid,0:nstepi),
     *clat(maxgrid,nstepi),slat(maxgrid,nstepi),rlon(maxgrid),
     *clon(nstepi,maxgrid),slon(nstepi,maxgrid),
     *ra(maxgrid,nstepi),hh(maxgrid),
     *g(maxgrid,maxgrid),
     *covf(maxgrid),c(maxgrid*(maxgrid+1)/2),rh(maxobs),izero(maxgrid),
     *degv(maxd),deg0(maxd),
     *sno(maxobs),iko(maxobs),rc(maxobs),
     *pnm(0:maxcof),pnm1(0:maxcof),sdeg(0:maxcof,8),
     *pnmr(maxgrid,5,nstepi),ersum(-maxcof:maxcof),
     *ssdeg(0:maxcof,8),fc(0:25),sscv(0:25),cv(0:25),nc(0:25),
     *iha(0:25),nolda(maxgrid,nstepi),molda(maxgrid,nstepi),
     *lmean1(maxgrid)
      dimension cclon(maxgrid*nstepi),sslon(maxgrid*nstepi)
      equivalence (clon(1,1),cclon(1))
      equivalence (slon(1,1),sslon(1))
c
      lmean=lmean1(i).and.lmean1(j1)
      if (lmean1(i)) then
       nsteps=nstepi
       sdloni=dlon*(d1+nstepi)/(d2*nstepi)
       ddloni=dlon/nstepi
      else
       nsteps=1
       sdloni=d0
       ddloni=d0
      end if
      if (lmean1(j1)) then
       nstept=nstepi
       sdlonj=dlon*(d1+nstepi)/(d2*nstepi)
       ddlonj=dlon/nstepi
      else
       nstept=1
       sdlonj=d0
       ddlonj=d0
      end if
      rji=d0
c
      c0=d0
      do ks=1,nsteps
       clati=clat(i,ks)
       slati=slat(i,ks)
       rai=ra(i,ks)
c      write(*,*)' rai ',i,ks,rai
       s=RE/rai
       rlonj=rlon(j)-ddlonj
       do kj=1,nsteps
        rlonj=rlon(j)-sdloni+kj*ddloni
c
        do kt=1,nstept
         clatj=clat(j1,kt)
         slatj=slat(j1,kt)
         s1=RE/ra(j1,kt)
         do km=1,nstept
          if (lmean) then
           nm0=(m-1)*nstept+km-(j-1)*nsteps-kj
           nm=abs(mod(nm0,nstepi*n))+1
           cdlon=cclon(nm)
          else
           rlonm=rlon(m)-sdlonj+km*ddlonj
           cdlon=cos(rlonj-rlonm)
          end if
          t=slati*slatj+clati*clatj*cdlon                  
          if (abs(cdlon-cclon(nm)).gt.1.0d-8.and.
     *    m.lt.3.and.j.lt.3.and.lf) then
           write(*,10)j,kj,m,km,nm0,nm,cclon(nm),cdlon
  10      format(6i4,3f12.5)
          end if
c
          c0=c0+cov(maxdeg,degv,t,ih,ih1,s,s1)*clati*clatj
c change 2001-07-26 - earlier rji was incorrect.
          rji=rji+clati*clatj
          if (ltestc) write(*,907)kt,km,t,c0
 907      format(' ktmtc0 ',2i3,f10.5,d15.8)
         end do
        end do
c
       end do
      end do
c change 2003-02-16
      cmean=c0/(rji)       
      if (ltestc) write(*,908)i,j,j1,m,cmean,rji
 908  format(4i3,2d15.8)
      if (abs(cmean).gt.1.0d5 ) then
       write(*,*)' **** error in cmean '
       write(*,10)j,kj,m,km,nm0,nm,cclon(nm),cdlon,cmean
       stop         
      end if
      return
      end
C
      SUBROUTINE PRONLL(AN,INUL,H,NT,VAR,LRED,LBS,IANT,INULT,IHT)
C
C     THIS SUBROUTINE USES A CHOLESKY ALGORITHME FOR REDUCING
C     AND SOLVING THE SYSTEM OF LINEAR EQUATIONS
C                   (AT*A)*X=AT*Y
C     WHERE (AT*A) IS SYMMETRICAL POSITIV DEFINITE MATRIX OF
C     DIMENSION NT*NT, AND (AT*Y) IS A VECTOR OF DIMENSION NT.
C
C     CONTEND OF ARRAYES:
C             AN(.)         THE UPPER PART OF (AT*A), AND RETURNS
C                           WITH LT, WHERE L*LT=(AT*A), IF LRED =
C                           .TRUE.
C             INUL(.)       INDEX OF THE FIRST NON-ZERO ELEMENT
C                           OF EACH ROW.
C             H(.)          THE RIGHT-HANDSIDE (AT*Y), AND RETURNS
C                           WITH X ,IF LBS = .TRUE., ELSE WITH
C                           (L-1)*(AT*Y).
C             VAR           THE PSEUDO DIAGONAL ELEMENT OF (L-1)*
C                           (AT*Y).
C
C
C     PROGRAMMED BY
C                     PER KNUDSEN
C                     GEODETIC INST.
C                     DK-2920                      12.07.85.
C
C     IMPLICIT REAL*8 (A-H,O-Z)
      implicit none
      integer iht,inult,nt,ir,irt,inul,iant,is,ist,ii,irr,iit
      real*8 an,sum,h,var
      DIMENSION AN(IANT),INUL(INULT),H(IHT)
      LOGICAL LRED,LBS
C
C***  THE UPPER PART OF A IS REDUCED INTO LT IF LRED IS TRUE.
C
      IF(.NOT.LRED) GO TO 50
      DO 25 IS=1,NT
      IST=(IS*(IS-1))/2
      SUM=0.0D0
      DO 10 IR=INUL(IS),(IS-1)
      IRT=(IR*(IR-1))/2
      SUM=0.0D0
      DO 5 II=MAX0(INUL(IS),INUL(IR)),(IR-1)
      SUM=SUM+(AN(IRT+II)*AN(IST+II))
    5 CONTINUE
      AN(IST+IR)=(AN(IST+IR)-SUM)/AN(IRT+IR)
   10 CONTINUE
      SUM=0.0D0
      DO 15 II=INUL(IS),(IS-1)
      SUM=SUM+AN(IST+II)**2
   15 CONTINUE
c     write(*,*)ist,ii,an(ist+ii),sum
      IF ((AN(IST+IS)-sum).LE.1.0d-10) THEN
      WRITE(*,102)IS
  102 FORMAT(' NUMERICAL SINGULARITY IN ROW ',I4)
      write(*,*)ist,ii,an(ist+ii),sum
      NT=IS-1
      AN(IST+IS)=0.0D0
      GO TO 50
      else
      AN(IST+IS)=SQRT(AN(IST+IS)-SUM)
      end if
C
   25 CONTINUE
C
C
   50 CONTINUE
C***  SOLVE L-1*H
C
      DO 100 IR=1,NT
      IRT=(IR*(IR-1))/2
      SUM=0.0D0
      DO 90 II=INUL(IR),(IR-1)
      SUM=SUM+(AN(IRT+II)*H(II))
   90 CONTINUE
      H(IR)=(H(IR)-SUM)/AN(IRT+IR)
  100 CONTINUE
      SUM=0.0D0
      DO 101 II=1,NT
      SUM=SUM+H(II)**2
  101 CONTINUE
      VAR=SUM
C
C***  THE SOLUTION IS FOUND BY BACK SUBSTITUTUION IF LBS IS TRUE.
C
      IF(.NOT.LBS) RETURN
C
      DO 150 IRR=1,NT
      IR=NT+1-IRR
      IRT=(IR*(IR-1))/2
      SUM=0.0D0
      DO 140 II=(IR+1),NT
      IIT=(II*(II-1))/2
      SUM=SUM+(AN(IIT+IR)*H(II))
  140 CONTINUE
      H(IR)=(H(IR)-SUM)/AN(IRT+IR)
  150 CONTINUE
C
      RETURN
      END
      SUBROUTINE EUCLID(COSLAP,SINLAP,COSLOP,SINLOP,H,E2,AX)
C PROGRAMMED BY C.C.TSCHERNING, GEODETIC INSTITUTE OF DENMARK, 1974.
C UPDATES: 2001-01-25 by cct. 
C COMPUTATION OF EUCLIDIAN COORDINATES X,Y,Z , DISTANCE AND SQUARE OF
C DISTANCE FROM Z-AXIS XY, XY2 AND DISTANCE AND SQUARE OF DISTANCE FROM
C THE ORIGIN DISTO AND DIST2 FROM GEODETIC COORDINATES REFERING TO AN
C ELLIPSOID HAVING SEMI-MAJOR AXIS EQUAL TO AX AND SECOND EXCENTRICITY
C E2.
C     IMPLICIT INTEGER(I,J,K,M,N), REAL *8(A-H,O-Z)
      REAL*8 X,Y,Z,XY,XY2,DISTO,DIST2,rlatc,H,E2,AX,COSLAP,SINLAP,
     *COSLOP,SINLOP,DN
      COMMON /EUCL/X,Y,Z,XY,XY2,DISTO,DIST2,rlatc
C X,Y,Z ARE THE CARTESIAN COORDINATES, XY2 SQUARE OF DISTANCE FROM
C Z-AXIS, DISTO DISTANCE FROM ORIGIN, rlatc the geocentric latitude.
      DN = AX/ SQRT(1.0D0-E2*SINLAP**2)
      Z = ((1.0D0-E2)*DN+H)*SINLAP
      XY = (DN+H)*COSLAP
      XY2 = XY*XY
      DIST2 = XY2+Z*Z
      DISTO =  SQRT(DIST2)
      X = XY* COSLOP
      Y = XY* SINLOP
      rlatc=atan2(Z,XY)
      RETURN
      END
c -------------------------------------------------------------------
      subroutine lecurs(plm,ll,thet)
c --   One dim. recursion of Legendre column degree ll > 0.
c --   Two central half integral columns degree ll-1/2 also calc.
c --   symmetric left and right Edmonds recursion followed by
c --   partial binomial recursion onto Legendre column degree ll,
c --   repeated from column l=1 (initiated directly ) to degree ll,
c --     input :    ll   degree of  Legendre column wanted.
c --                thet colatitude (radians)
c --     output:    plm(m) Legendre value order m=(0:ll)
c --                d(i,1), i=0,2*ll Legendre column d-matrix degree ll
c --                (central column in d*matrix degree ll).
c --                dd(i,0) & dd(i,2), i=0,2*ll-1 degree ll-1/2 central
c --                (central columns in d-matrix degree ll).
c --                d & dd in common, equivalenced.
c --   Program by Torben Risbo, Geophyscal Institute, Copenhagen Univ.
c --   20 Feb 1992, last version 27 Apr 1992. Changed 2001-01-08 by cct.
c     implicit real*8 (a-h,o-z)
      implicit none
      integer maxd,L,LL,I,l2
      real*8 d,dd,plm,sqt,sq2,thet,q,pc,qc,p,fl
      parameter  (maxd=1800) 
      dimension d(0:2*maxd,0:2),dd(0:2*maxd,0:2)
c     dimension plm(0:maxd),sqt(0:maxd*2)
      dimension plm(0:maxd)
c     logical bool
c     save sqt,sq2,bool
      equivalence (d(0,0),dd(0,0))
      common d
      common /rrsph/sqt(0:maxd*2+2)
c     data bool /.false. /
c     if (bool) goto 5
      sq2 = sqrt(2.0d0)
c     bool = .true.
c     do 1 i=0,maxd*2
c   1 sqt(i)= sqrt(float(i))
c   5 p = sin(thet/2.0d0)
      p = sin(thet/2.0d0)
      q = cos(thet/2.0d0)
      pc= p
      qc= q
      plm(0) = 1.0d0
      if(ll .eq. 0) return
c ---- initialize column l=1 ----
      d(0,1)  =   sq2*q*p
      d(1,1)  =  -p*pc+q*qc
      d(2,1)  =  -sq2*pc*qc
      if (ll .eq. 1) then
      plm(0) = d(1,1)
      plm(1) = d(2,1)
      return
      endif
c -----  main loop --------------
      do 210 l=1,ll-1
      l2 = 2*l
      do 10 i=0,l2+1
      dd(i,0) = 0.0d0
      dd(i,2) = 0.0d0
   10 continue
c --  recursion from d to dd, after Edmonds scheme to left and right.
      do 110 i=0,l2
      dd(i,0)    = dd(i,0)    +    sqt(l2+1-i)/sqt(l+1)*d(i,1)*q
      dd(i+1,0)  = dd(i+1,0)  -    sqt(i+1)/sqt(l+1)*d(i,1)*pc
      dd(i,2)    = dd(i,2)    +    sqt(l2+1-i)/sqt(l+1)*d(i,1)*p
      dd(i+1,2)  = dd(i+1,2)  +    sqt(i+1)/sqt(l+1)*d(i,1)*q
  110 continue
  100 continue
c ---  null d column
      do 30 i=0,l2+2
      d(i,1) = 0.
   30 continue
c --  binom recursion from dd to central column d --
      fl = float(l2+2)
      do 120 i=0,l2+1
      d(i,1)    = d(i,1)   +    sqt(l2+2-i)*sqt(l+1)/fl*dd(i,2)*q
      d(i+1,1)  = d(i+1,1) -    sqt(i+1)*sqt(l+1)/fl*dd(i,2)*pc
      d(i,1)    = d(i,1)   +    sqt(l2+2-i)*sqt(l+1)/fl*dd(i,0)*p
      d(i+1,1)  = d(i+1,1) +    sqt(i+1)*sqt(l+1)/fl*dd(i,0)*qc
  120 continue
  210 continue
c --- output Legendre values in plm(m) (m=0:l) -----
      do 75 i=0,ll
      plm(i) = d(i+ll,1)
   75 continue
      return
      end
c---------------------------------------------------------
      subroutine chort(maxgrid,n,rlon)
c subroutine to check orthogonality of sin and cosine.
c programmed 2000-12-01 by C.C.Tscherning.
c     implicit real*8 (a-h,o-z)
      implicit none
      integer k,n,maxgrid,k1,k2,j
      real*8 d0,d1,rlon,scqn,ssqn,sumc,sums,sucs
c rlon holds the longitudes, n the number of points.
      dimension rlon(maxgrid),scqn(1444),ssqn(1444)
c            
      d0=0.0d0
      d1=1.0d1
      write(*,*)' k,  cos(k-1*dlon), sin(k-1*dlon) '
      do k=1,n
       write(*,67)k,cos(rlon(k)),sin(rlon(k))
  67   format(i3,2f10.6)
      end do
c
C check ortogonality.
      write(*,*)' i, j, sum c(i*l)*c(j*l), s*s, cos*sin '
      do k=0, n
       do  k1=0,k
        sumc=d0
        sums=d0
        sucs=d0
        do j=1,n
         sumc=sumc+cos(k*rlon(j))*cos(k1*rlon(j))
         sums=sums+sin(k*rlon(j))*sin(k1*rlon(j))
         sucs=sucs+sin(k*rlon(j))*cos(k1*rlon(j))
        end do
        do k2=1,n
         scqn(k2)=d0
         ssqn(k2)=d0
         do j=1,n
          scqn(k2)=
     *    scqn(k2)+cos(k*rlon(j))*cos(k1*(rlon(j)-rlon(k2)))
           ssqn(k2)=
     *    ssqn(k2)+sin(k*rlon(j))*cos(k1*(rlon(j)-rlon(k2)))
         end do
        end do
c
        write(*,76)k,k1,sumc,sums,sucs
 76     format(2i5,3f10.6)
        write(*,77)(scqn(k2),k2=1,n)
        write(*,77)(ssqn(k2),k2=1,n)
 77     format(' sqn ',8f8.4)
       end do
      end do
      return
      end
      double precision function spharm0(slat,clat,r,i0,j0,lfull
     *,pii,pim0,pim1,pim2,iold,jold)
c Calculation of the values of solid spherical harmonic functions
c Y(i0,j0)(lat,lon,r) using recursion based on Y(i0-1,j0), Y(i0-2,j0) 
c when j0 .ne. j0. Otherwise the recursion is based on Y(i0-1,j0-1) and
c Y(i0-2,j0-1).
c Reference:
c Tscherning, C.C. and K.Poder: Some Geodetic applications of Clenshaw
c Summation. Bolletino di Geodesia e Scienze Affini, Vol. XLI, no. 4,
c pp. 349-375, 1982.
c                 
c variables at call: slat, clat: sine and cosine of latitude, r the
c size of the radius vector, 
c lfull a logical variable true if fully normalized functions 
c are used.
c
c call and return variables:
c pii, pim0, pim1, pim2 values used in last reqursion step for the
c computation of associated Legendre functions.
c at the very first step (i0=j0=0) pim0 := d1.
c
c Last change 2001-06-13 by cct.
c
c     implicit real*8 (a-h,o-z), logical (l)
      implicit none
      integer maxd,i,j,j1,jold,j0,i0,iold
      parameter (maxd=1800)
      logical lfull,LTEST,LF,LT
      real*8 D0,D1,D2,D3,D4,D5,RE,RADSEC,PI,GM,pim1,pim2,fact,v,pm,
     *b,slat,a,clat,rq,pim0,pii,r,q,root,sq2
c
      COMMON /DCON/D0,D1,D2,D3,D4,D5,RE,RADSEC,PI,GM,LTEST,LF,LT
      common /rrsph/root(0:maxd*2+2)
c root is a precomputed square root-table (root(0)=0 !).
      sq2=root(2)
      q=re/r
      j=j0
      i=i0
      j1=j+1
      if (i.eq.j) then
       if (j.ne.(jold+1)) write(*,*)' WARNING j, jold ',j,jold
       pim2=d0
       pim1=d0
       if (i.eq.0) then
        pii=q
        pim0=pii
       else
        rq=root(2*i-1)/root(2*i)*q
        pim0=pii*clat*rq
        pii=pim0
       end if
      else
       if (j.ne.jold.or.i.ne.(iold+1)) write(*,*)' WARNING i,j '
       a=(d2*i-d1)/(root(i+j)*root(i-j))*q
       pim2=pim1
       pim1=pim0
       pim0=a*slat*pim1
       if (i.gt.j) then
        b=-q**2*root(i-j-1)*root(i+j-1)/(root(i-j)*root(i+j))
        pm= b*pim2
        pim0=pim0+pm
       end if
      end if
      v=pim0
      iold=i
      jold=j
      if (lfull) then
c normalisation.
       if (j.eq.0) then
        fact= root(2*i+1)
       else
        fact= root(2*i+1)*sq2
       end if
       v=v*fact
      end if
      spharm0=v
      if (abs(spharm0).gt.1.0d200) write(*,*)
     *' Error  in spharm0 ',i,j,spharm0
c
      return
      end
      SUBROUTINE TRANS(RLATP,HP)
C ORIGINAL VERSION PROGRAMMED IN 1974 BY C.C.TSCHERNING, GEODAETISK
C INSTITUT. LATEST UPDATE 2003-01-31.
c added 2003-01-31.
C
C THE SUBROUTINE TRANSFORMS THE CARTESIAN COORDINATES
C TO GEODETIC LATITUDE AND ELLIPSOIDAL HEIGHT, HP.
C
C IF DOUBLE PRECISION IS NEEDED ACTIVATE:
      IMPLICIT INTEGER(I,J,K,N,M),LOGICAL(L),REAL *8(A-H,O-Z)
      logical ltest,lf,lt
      COMMON /DCON/D0,D1,D2,D3,D4,D5,RE,RADDEG,PI,GM,LTEST,LF,LT
      COMMON /EUCL/X,Y,Z,XY,XY2,DISTO,DIST2,rlatc
c resulting cartesian coordinates and geocentric latitude.
      COMMON /ITRANC/AX2,E22
      X0=X
      Y0=Y
      Z0=Z
      XY20= X0*X0+Y0*Y0
      XY0 =  SQRT(XY20)
      DIST20 = XY20+Z0*Z0
      DISTO0 =  SQRT(DIST20)
C
C  COMPUTATION OF THE NEW GEODETIC LATITUDE, CF REF(C) PAGE 183.
      S = AX2
      DH = D0
      RLAT1 = D0
      COSLA=1.0D0
   70 RLAT = RLAT1
C
      RLAT1 =  ATAN2(Z0,XY0-E22*S*COSLA)
      COSLA =  COS(RLAT1)
      S = AX2/ SQRT(D1-E22*(D1-COSLA**2))
      DH = XY0/COSLA-S
      IF ( ABS(RLAT1-RLAT).GT.1.0D-10) GO TO 70
C
      RLATP = RLAT1
      HP=DH 
C
      RETURN
      END 
